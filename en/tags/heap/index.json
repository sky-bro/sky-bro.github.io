[{"content":"How to select k out of N objects.\nReservoir sampling  source code\n Reservoir sampling is a family of randomized algorithms for choosing a simple random sample, without replacement, of k items from a population of unknown size n in a single pass over the items.\n The size of the population n is not known and is typically very large. (scan from left to right, without looking back) At any point, the current state is a simple random sample without replacement of size k over the part of the population seen so far.  Simple algorithm (Algorithm R) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /** * A simple and popular but slow algorithm, commonly known as Algorithm R * time complexity O(n) */ void reservoir_sample(vector\u0026lt;int\u0026gt; \u0026amp;S, vector\u0026lt;int\u0026gt; \u0026amp;R, int k) { R.resize(k); copy(S.begin(), S.begin()+k, R.begin()); for (int i = k, n = S.size(); i \u0026lt; n; ++i) { int j = rand_int(0, i); if (j \u0026lt; k) R[j] = S[i]; // choose ith with probability (k/(i+1))  // keep ith with  // probability not being swapped by remmaing elements [i+1...n-1]  // (k/(i+1)) * (1-1/(i+2))*...*(1-1/n) = k/n  } }   An optimal algorithm (Algorithm L) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /** * Algorithm L improves upon this algorithm by * computing how many items are discarded before * the next item enters the reservoir * time complexity O(k(1+log(n/k))) */ void reservoir_sample(vector\u0026lt;int\u0026gt; \u0026amp;S, vector\u0026lt;int\u0026gt; \u0026amp;R, int k) { R.resize(k); copy(S.begin(), S.begin()+k, R.begin()); double W = exp(log(rand_real(0, 1))/k); for (int i = k, n = S.size(); i \u0026lt; n;) { i += floor(log(rand_real(0, 1))/log(1-W)) + 1; if (i \u0026lt; n) { R[rand_int(0, k-1)] = S[i]; W *= exp(log(rand_real(0, 1))/k); } } }   Problems for practice Refs  wiki: Reservoir sampling C++ randomly sample k numbers from range 0:n-1 (n \u0026gt; k) without replacement ","description":"","id":2,"section":"posts","tags":[""],"title":"Sampling","uri":"https://k4i.top/en/posts/sampling/"},{"content":"max_heap: A[0] is the maximum value\nmin_heap: A[0] is the minimum value\nsource code: AC/Algorithms/Heap\nintro  go_up(int i): from node i go up to at most node 0, swap with parent if node i is bigger (time: $O(log(n))$) go_down(int i): from node i go down to its leaf child at most, swap with the larger child every time goes down (time: $O(log(n))$) heapify(n): adjust A[0..n-1] as a heap with go_down (time: $O(n)$, refer: How is make_heap in C++ implemented to have complexity of 3N?) push(int x): A[sz] = x, then go_up(sz++) (time: $O(log(n))$, same as go_up) pop(): swap(A[0], A[--sz]), then go_down(0) (time: $O(log(n))$, same as go_down)  code complete source code on github\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 1e5; int sz = 0; // here is a max_heap, A[0] is the maximum value int A[N]; void go_down(int i) { for (int j = 2 * i + 1; j \u0026lt; sz; j = 2 * (i = j) + 1) { // j: left child of i  if (j \u0026lt; sz - 1 \u0026amp;\u0026amp; A[j] \u0026lt; A[j + 1]) ++j; // go to right child  if (A[i] \u0026gt;= A[j]) break; swap(A[i], A[j]); } } void go_up(int i) { for (int p = (i - 1) / 2; i; p = ((i = p) - 1) / 2) { if (A[i] \u0026lt;= A[p]) break; swap(A[i], A[p]); } } void heapify(int n) { if (n == 1) return; int i = (n - 2) / 2; while (true) { go_down(i); if (i-- == 0) return; } } void pop() { if (sz \u0026lt;= 1) { sz = 0; return; } swap(A[0], A[--sz]); go_down(0); } void push(int x) { A[sz] = x; go_up(sz++); }   Refs  How is make_heap in C++ implemented to have complexity of 3N? STL source code: make_heap, push_heap, pop_heap, \u0026hellip; ","description":"","id":3,"section":"posts","tags":["heap"],"title":"Heap Simple Implementation","uri":"https://k4i.top/en/posts/heap-simple-implementation/"},{"content":"I used to think deploying my blog with github actions is unnecessary, but now\u0026hellip; (真香)\nDeploying with github actions is so much faster.\nIntroduction I have two repositories: sky-bro/blog-src and sky-bro/sky-bro.github.io.\nBefore settign up github actions, I wrote my posts in sky-bro/blog-src, then build it on my computer and push the built files (in the public/ folder) to sky-bro/sky-bro.github.io using a script ./deploy.sh.\nNow every time I push to blog-src, the workflow runs, and deploy the newest build to the sky-bro.github.io repo.\nfinal workflow file Put this in .github/workflows/\u0026lt;workflow name\u0026gt;.yml, mine is at .github/workflows/gh-pages.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  name:deploy to sky-bro.github.ioon:push:branches:- master # Set a branch to deployworkflow_dispatch:jobs:deploy:runs-on:ubuntu-18.04steps:- uses:actions/checkout@v2with:submodules:true# Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:\u0026#39;latest\u0026#39;extended:true- uses:actions/cache@v2with:path:/tmp/hugo_cachekey:${{ runner.os }}-hugomod-${{ hashFiles(\u0026#39;**/go.sum\u0026#39;) }}restore-keys:|${{ runner.os }}-hugomod-- name:Buildrun:hugo --minify- name:Deployuses:peaceiris/actions-gh-pages@v3with:deploy_key:${{ secrets.ACTIONS_DEPLOY_KEY }}external_repository:sky-bro/sky-bro.github.iopublish_branch:masterpublish_dir:./publicfull_commit_message:${{ github.event.head_commit.message }}  workflow explained there are three main sections:\n name: name of the workflow (deploy to sky-bro.github.io) on: rules to trigger this workflow (my workflow will be triggered after pushing to the master branch or manually in the Actions tab) jobs: actual jobs to do after being trigered  This workflow only contains one job, and the name of this job is deploy, it has some steps, which will be executed in the given order.\nStep 1. check out files Just copy.\nThe hugo themes are in theme/ folder as submodules.\nThe fetch depth is set to 0 so we can fetch all history for .GitInfo and .Lastmod. (some hugo themes need this)\nStep 2. Set up hugo Set the version number ('0.79.1', latest), and decide whether or not you want to use the hugo extended. (If your theme uses SASS/SCSS, you need hugo extended)\nStep 3. Set hugo cache optional, just copy.\nStep 4. Build your site Giving --minify will let hugo minify any supported output format (HTML, XML etc.).\nStep 5. Deploy your site This is the most important one.\n deploy_key, github_token or personal_token: three types of tokens, choose the one you need publish_dir is where the site files are generated, hugo uses ./public by default commit_message or full_commit_message, full_commit_message will not include hash at the end of the deploy commit. ${{ github.event.head_commit.message }} is the latest commit message of your source. external_repository, publish_branch: where you\u0026rsquo;ll deploy you site (if using another repository)  If you have your site deployed in the same repository.\nYou can use github_token, just add github_token: ${{ secrets.GITHUB_TOKEN }} under with:, like below. This is the simplest. Then follow First Deployment with GITHUB_TOKEN\n1 2 3 4 5  - name:Deployuses:peaceiris/actions-gh-pages@v3with:github_token:${{ secrets.GITHUB_TOKEN }}publish_dir:./public  But sometimes, you would like to deploy your site to a different repository, you can only use deploy_key or personal_token to deploy to a different repository.\nI used a personal_token (ref: Create SSH Deploy Key).\nFirst generate your deploy key with the following command.\n1 2 3 4  ssh-keygen -t rsa -b 4096 -C \u0026#34;$(git config user.email)\u0026#34; -f gh-pages -N \u0026#34;\u0026#34; # You will get 2 files: # gh-pages.pub (public key) # gh-pages (private key)   Next, go to the repository settings\n of your target repository (where you deploy you site to). Go to Deploy Keys and add your public key with the Allow write access. of your source repository. Go to Secrets and add your private key as ACTIONS_DEPLOY_KEY  Refs  peaceiris/actions-hugo peaceiris/actions-gh-pages, most contents of this post can be found here. ","description":"","id":4,"section":"posts","tags":["hugo","github actions"],"title":"Hugo, Deploy With Github Actions","uri":"https://k4i.top/en/posts/deploy-with-github-actions/"},{"content":"My simple note on the RSA algorithm.\nIntroduction We know that RSA is an asymmetric encryption algorithm, meaning that the communication partners Alice and Bob hold different keys, instead of same keys as in symmetric encryption.\nIn rsa, Alice first computes the product $n$ of two different large prime numbers $p$ and $q$, and uses $p$ and $q$ to derive two keys $e$ and $d$, one for herself and one for others. Then she makes $(e, n)$ public and destroies the $p$ and $q$.\nEncryption and Decryption  $e$ and $d$ can both be used for encryption or decryption: $e$ can be used to decpryt what\u0026rsquo;s encrypted with $d$, $d$ can be used to decpryt what\u0026rsquo;s encrypted with $e$\n   To Encrypt\nIf Alice encrypts a message m, she need to compute $m^d \\equiv c\\ (\\text{mod}\\ n)$\n  To Decrypt\nBob knows $(e, n)$ (everyone knows, because this is public), he computes $c^e \\equiv m^{de} \\equiv m\\ (\\text{mod}\\ n)$ and gets the original message m.\n  So the correctness of RSA lies in $m^{de}\\equiv m\\ (\\text{mod}\\ n)$. We\u0026rsquo;ll understand why in the Proof of Correctness Section.\nHow to Generate e and d  $\\phi(n)=(p-1)\\times (q-1)$ choose an integer $e$ which is a smaller than coprime to $\\phi(n)$, A popular choice is $e = 2^{16} + 1 = 10001\\text{h} = 65537$ the modular inverse of $e$ modulo $\\phi(n)$ is $d$, it can be computed with Extended Euclidean algorithm in PKCS #1 v2.0, $\\phi(n)$ has been replaced with $\\lambda(n) = \\text{lcm}(p-1,q-1)$  Euler\u0026rsquo;s totient function $\\phi(n)$: the number of positive integers up to $n$ that are relatively prime to $n$.\nFor example, $\\phi(9)=6$, because there are 6 numbers relatively prime to 9: $\\{1,2,4,5,7,8\\}$\nMore generally, for any number $N$, it can be represented as the product of some prime numbers: $N = p_1^{k_1}\\times p_2^{k_2}\\times p_3^{k_3}\\times \u0026hellip;$, and $\\phi(N)=N\\times(1-\\frac{1}{p_1})\\times(1-\\frac{1}{p_2})\\times(1-\\frac{1}{p_3})\u0026hellip;$\nCompute Modular Inverse There are three ways to compute modular inverse, please refer to this post\nProof of Correctness Euler\u0026rsquo;s totient theorem  $m^{\\phi(n)}=1\\ (\\text{mod}\\ n)$ when $m$ and $n$ are coprime special case: $m^{n-1}=1\\ (\\text{mod}\\ n)$ when $n$ is a prime number and $m$ and $n$ are coprime ($m$ is not a multiple of $n$) \u0026ndash; Fermat’s Little Theorem  Chinese Remainder Theorem TODO\nCorrectness of RSA  we know that $ed = 1\\ (\\text{mod}\\ \\lambda(pq))$, $\\lambda(pq) = \\text{lcm}(p-1, q-1)$. $ed = 1\\ (\\text{mod}\\ \\lambda(pq))$, that is $ed=h(p-1)+1 = k(q-1)+1$ In order to prove $m^{ed}\\equiv m\\ (\\text{mod}\\ pq)$, it\u0026rsquo;s equivalent to prove $m^{ed}\\equiv m\\ (\\text{mod}\\ p)$ and $m^{ed}\\equiv m\\ (\\text{mod}\\ q)$ separately (using Chinese Remainder Theorem)  prove $m^{ed}\\equiv m\\ (\\text{mod}\\ p)$\n$$\n\\begin{align*}\nm^{ed} \u0026amp;= m^{h(p-1)+1}\\ (\\text{mod}\\ p)\\\\\n\u0026amp;= 0\\ \\text{(when m is multiple of p) or}\\ (1)^{h}\\times m\\ \\text{(when m and p are coprime)}\\\\\n\u0026amp;= m\\ (\\text{mod}\\ p)\n\\end{align*}\n$$ prove $m^{ed}\\equiv m\\ (\\text{mod}\\ q)$\n$$\n\\begin{align*}\nm^{ed} \u0026amp;= m^{k(q-1)+1}\\ (\\text{mod}\\ q)\\\\\n\u0026amp;= 0\\ \\text{(when m is multiple of q) or}\\ (1)^{k}\\times m\\ \\text{(when m and q are coprime)}\\\\\n\u0026amp;= m\\ (\\text{mod}\\ q)\n\\end{align*}\n$$    refs  wiki: RSA wiki: Euler\u0026rsquo;s totient function wiki: Euler\u0026rsquo;s totient theorem wiki: Chinese remainder theorem slide: Correctness Proof of RSA, I think the proof is wrong, (when applying Fermat’s Little Theorem, didn\u0026rsquo;t consider the case when m is multiple of p). wiki: Extended Euclidean algorithm 同余定理+逆元】知识点讲解 ","description":"","id":5,"section":"posts","tags":["RSA","Crypto"],"title":"Understand RSA, a Top Dwon Approach","uri":"https://k4i.top/en/posts/understand-rsa-a-top-dwon-approach/"},{"content":"BIT can be used to compute the prefix sum of an array in $log(n)$ time and takes only $O(n)$ space.\n source code\n Introduction Binary Indexed Tree (BIT, or Fenwick Tree), is used for computing the prefix sum (some associative binary operation) of an array, and it can modify an element by adding some value to that element.\nUnlike Segment Tree, Fenwick Tree cannot let you query a range, it\u0026rsquo;s only used for querying the prefix sum. (But depends on the sum operation, you can sometines get a range sum from two prefix sums).\nFenwick Tree takes only $O(n)$ space, whereas segment tree takes $O(2n)$ space, or $O(4n)$ if you use lazy propagation.\nFenwick Tree has two functions. They are sum and add, as shown below.\nadd increase an element 1 2 3  void add(int i, T v) { // adds v to A[i]  while (i \u0026lt;= n) A[i] += v, i += i \u0026amp; -i; }    (i \u0026amp; -i) will get the lowest bit of i, for example (6 \u0026amp; -6) = 0b10 = 2\n Elements are 1-indexed here, so A[0] is not used.\nsum get a prefix sum 1 2 3 4 5  T sum(int i) { // prefix sum: A[1] + A[2] + ... + A[i]  T v{}; while (i) v += A[i], i -= i \u0026amp; -i; return v; }   TODO\ntemplate  source code\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  template \u0026lt;typename T\u0026gt; class fenwick { public: int n; vector\u0026lt;T\u0026gt; A; fenwick(int n): n(n), A(n+1) {} // A[0] not used  T sum(int i) { // prefix sum: A[1] + A[2] + ... + A[i]  T v{}; while (i) v += A[i], i -= i \u0026amp; -i; return v; } void add(int i, T v) { // adds v to A[i]  while (i \u0026lt;= n) A[i] += v, i += i \u0026amp; -i; } };   Refs  wiki: Fenwick Tree ","description":"","id":6,"section":"posts","tags":["BIT","Fenwick","Tree"],"title":"Binary Indexed Tree, or Fenwick Tree","uri":"https://k4i.top/en/posts/binary-indexed-tree-or-fenwick-tree/"},{"content":"Use matrix and fast pow together can make some problems much easier.\nFast Pow old friend fast pow:\n1 2 3 4 5 6 7 8 9 10  template \u0026lt;typename T\u0026gt; T pow(T x, int n) { T ret = 1; while (n) { if (n \u0026amp; 1) ret *= x; x *= x; n \u0026gt;\u0026gt;= 1; } return ret; }   Matrix\u0026lt;ll, 10, 10, MOD\u0026gt; ret = 1 will use constructor Matrix(T x, bool isMainDiagonal = true).  A Matrix Template 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  template \u0026lt;typename T, std::size_t R, std::size_t C = R, std::size_t M = INT32_MAX\u0026gt; class Matrix { public: T m[R][C]; Matrix() { memset(m, 0, sizeof(m)); } /** * construct a matrix whose diagonal (fill at most min(R, C) number as x) is * filled with number x, and the rest filled with 0\u0026#39;s * @param x number to be filled at the diagonal * @param isMainDiagonal fill main diagonal if true, else fill the * antidiagonal */ Matrix(T x, bool isMainDiagonal = true) : Matrix() { if (isMainDiagonal) for (std::size_t i = 0; i \u0026lt; R \u0026amp;\u0026amp; i \u0026lt; C; ++i) m[i][i] = x; else for (std::size_t i = 0, j = C - 1; i \u0026lt; R \u0026amp;\u0026amp; j \u0026gt;= 0; --j, ++i) m[i][j] = x; } template \u0026lt;std::size_t C2\u0026gt; Matrix\u0026lt;T, R, C2, M\u0026gt; operator*(const Matrix\u0026lt;T, C, C2, M\u0026gt; \u0026amp;other) const { Matrix\u0026lt;T, R, C2, M\u0026gt; res; for (std::size_t i = 0; i \u0026lt; R; ++i) for (std::size_t k = 0; k \u0026lt; C; ++k) for (std::size_t j = 0; j \u0026lt; C2; ++j) res.m[i][j] = (res.m[i][j] + m[i][k] * other.m[k][j] % M) % M; return res; } Matrix\u0026lt;T, R, C, M\u0026gt; \u0026amp;operator*=(const Matrix\u0026lt;T, C, C, M\u0026gt; \u0026amp;other) { return *this = *this * other; } void fill(T x) { for (std::size_t i = 0; i \u0026lt; R; ++i) for (std::size_t j = 0; j \u0026lt; C; ++j) m[i][j] = x; } T sum() const { T res = 0; for (std::size_t i = 0; i \u0026lt; R; ++i) for (std::size_t j = 0; j \u0026lt; C; ++j) res = (res + m[i][j]) % M; return res; } };   Examples leetcode: 509 Fibonacci Number  link: 509 Fibonacci Number\ntime: $O(log(n))$, space: $O(1)$\n description $$\n\\begin{align*}\nF(0) \u0026amp;= 0 \\\\\nF(1) \u0026amp;= 1 \\\\\nF(n) \u0026amp;= F(n - 1) + F(n - 2),\\;for\\; n \u0026gt; 1.\n\\end{align*}\n$$\nnow given n, compute F(n);\nidea keep track of previous two numbers F(i-2), F(i-1), and update them at each increase of i, till we get to n.\nthe transition can be represented by a matrix, mulitply all transition matrixes together (use fast pow here) then transit once from initial state F(0) = 0, F(1) = 1.\nsolution  code on github: sky-bro/AC/leetcode.com/0509 Fibonacci Number/\n 1 2 3 4 5 6 7 8 9 10 11 12  class Solution { public: int fib(int N) { Matrix\u0026lt;ll, 1, 2, MOD\u0026gt; res; res.m[0][1] = 1; if (N \u0026lt; 2) return N; Matrix\u0026lt;ll, 2, 2, MOD\u0026gt; x; // transition matrix  x.fill(1); x.m[0][0] = 0; return (res * pow(x, N - 1)).m[0][1]; } };   leetcode: 935 Knight Dialer  link: 935 Knight Dialer\ntime: $O(log(n))$, space: $O(1)$\n description 1 2 3 4 5 6  /* 1 2 3 4 5 6 7 8 9 * 0 # */   how many different sequence of numbers can a chess knight dial (% 109 + 7). the knight can only stand on numeric cells, and may start from any digit.\nidea This is a simple dp problem, at every move, knight standing at 1 can go to 6 and 8 (or knight standing at 6 and 8 can go to 1), so dp[1] = dp[6] + dp[8], but we need to update all dp[0..9] same time (we don\u0026rsquo;t want to overwrite dp values in the last step), so the time and space complexity would be $O(n)$ and $O(1)$.\nAnother way to update dp values is by multiplying a transition matrix, and in every transition, this matrix is gonna be the same, so we just multiply all transitions together (where can use fast pow) and transit from the starting point (when n=1: [1,1,1,1,1,1,1,1,1,1]) only once.\nThe time complexity would be reduced to $O(log(n))$.\nsolution  code on github: sky-bro/AC/leetcode.com/0935 Knight Dialer/\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public: int knightDialer(int n) { if (n == 1) return 10; Matrix\u0026lt;ll, 1, 10, MOD\u0026gt; res; res.fill(1); /* 1 2 3 4 5 6 7 8 9 * 0 # */ Matrix\u0026lt;ll, 10, 10, MOD\u0026gt; x; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; trans = { {4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4} }; for (int i = 0; i \u0026lt; 10; ++i) for (int j : trans[i]) x.m[i][j] = 1; return (res * pow(x, n - 1)).sum(); } };   more for exercise  todo\u0026hellip;  refs  Matrix - By DanAlex ","description":"","id":7,"section":"posts","tags":["fast pow","matrix"],"title":"Matrix Fast Pow","uri":"https://k4i.top/en/posts/matrix-fast-pow/"},{"content":"knapsack problem and its variations\n0-1 knapsack problem description Given a set of $n$ items, each with a weight $w_{i}$ and a value $v_{i}$, along with a maximum weight capacity $W$, try pick some of these items (total weight not surpassing $W$), so that the total value is maximized, find the maximum total value.\nsolution to acwing: 01背包问题  problem link\ntime: $O(NV)$, space: $O(V)$\nfor every item, total weight of items in our knapsack decrease (so that we take each item at most once) from maximum (knapsack volume) to current item\u0026rsquo;s weight.\ndp[v] is the maximum value we get with total weight of $v$ (or less) if we do not take in this item;\ndp[v-p.first] + p.second is the maximum value we get with total weight of $v$ (or less) if we take this item.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; static int x = []() { std::ios::sync_with_stdio(false); cin.tie(0); return 0; }(); typedef long long ll; int N, V; int solve(vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;A) { vector\u0026lt;int\u0026gt; dp(V + 1); for (auto \u0026amp;p : A) { for (int v = V; v \u0026gt;= p.first; --v) { dp[v] = max(dp[v], dp[v - p.first] + p.second); } } return *max_element(dp.begin(), dp.end()); } int main(int argc, char const *argv[]) { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; // volume  vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; A(N); for (int i = 0; i \u0026lt; N; ++i) { cin \u0026gt;\u0026gt; A[i].first \u0026gt;\u0026gt; A[i].second; // (weight, value)... not (value, weight)  } cout \u0026lt;\u0026lt; solve(A) \u0026lt;\u0026lt; endl; return 0; }   count ways / check valid way exists  leetcode: 416 Partition Equal Subset Sum\ntime: $O(NV)$, space: $O(V)$\nnow we need to count the number of ways to form exact $V$ total weight\nsimilar as above, but initialize dp[0]=1, and rest as 0.\nif we do not need to count the number of ways, but just check if there exists one valid way, use or operation indead of +.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // cannot count ways, gets overflow, use \u0026#39;|\u0026#39; operation is enough class Solution { public: bool canPartition(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int sum = accumulate(nums.begin(), nums.end(), 0); if (sum \u0026amp; 1) return false; vector\u0026lt;int\u0026gt; dp(sum / 2 + 1); dp[0] = 1; for (int num : nums) { for (int i = sum / 2; i \u0026gt;= num; --i) { dp[i] |= dp[i - num]; // dp[i] += dp[i - num]; // overflow, if number of ways is too big  } } return dp[sum / 2]; } };   1 2 3 4 5 6 7 8 9 10 11 12  // for 0-1 knapsack problem, using bitset is more simple -- update all bits same time // use bitset // https://leetcode.com/problems/partition-equal-subset-sum/discuss/90590/Simple-C%2B%2B-4-line-solution-using-a-bitset class Solution { public: bool canPartition(vector\u0026lt;int\u0026gt;\u0026amp; nums) { bitset\u0026lt;10001\u0026gt; bits(1); int sum = accumulate(nums.begin(), nums.end(), 0); for (int num : nums) bits |= bits \u0026lt;\u0026lt; num; return !(sum \u0026amp; 1) \u0026amp;\u0026amp; bits[sum \u0026gt;\u0026gt; 1]; } };   get a valid path Often in 0-1 knapsack problems, we want to know exactly the what set of objects we take (maybe multiple, but we just need any one of them).\nTo achieve this, we only need an extra array of size V (which is the volume of our knapsack). Idea is that we store at path[i] the object that first let us arrive volume i.\n (haven\u0026rsquo;t found a proper/simple example problem yet\u0026hellip; to be added)\n If we want to get a valid set of integers (objects) in the above problem: leetcode: 416 Partition Equal Subset Sum\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { public: bool canPartition(vector\u0026lt;int\u0026gt;\u0026amp; nums) { bitset\u0026lt;10001\u0026gt; bits(1); int sum = accumulate(nums.begin(), nums.end(), 0); vector\u0026lt;int\u0026gt; path((sum \u0026gt;\u0026gt; 1) + 1); for (int num : nums) { auto change = bits; bits |= bits \u0026lt;\u0026lt; num; change ^= bits; // set bits that changed in this loop  for (int i = change._Find_first(); i \u0026lt;= a; i = change._Find_next(i) { path[i] = num; } } if (!(sum \u0026amp; 1) \u0026amp;\u0026amp; bits[sum \u0026gt;\u0026gt; 1]) { for (int j = sum \u0026gt;\u0026gt; 1; j; ) { cout \u0026lt;\u0026lt; path[j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; j -= path[j]; } cout \u0026lt;\u0026lt; endl; } return !(sum \u0026amp; 1) \u0026amp;\u0026amp; bits[sum \u0026gt;\u0026gt; 1]; } };   unbounded knapsack problem description similar to the 0-1 knapsack problem, but now there are infinite number of each item, so we can take multiple of each.\nsolution to acwing: 完全背包问题  problem link\ntime: $O(NV)$, space: $O(V)$\nonly difference from the 0-1 knapsack problem solution is that now for each item, total weight of items in our knapsack increases (so we can re-put this item in our knapsack) from current item\u0026rsquo;s weight to maximum (knapsack\u0026rsquo;s volume)\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; static int x = []() { std::ios::sync_with_stdio(false); cin.tie(0); return 0; }(); typedef long long ll; int N, V; int solve(vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;A) { vector\u0026lt;int\u0026gt; dp(V + 1); for (auto \u0026amp;p : A) { for (int v = p.first; v \u0026lt;= V; ++v) { // only difference from 0-1 knapsack problem  dp[v] = max(dp[v], dp[v - p.first] + p.second); } } return dp[V]; } int main(int argc, char const *argv[]) { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; // volume  vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; A(N); for (int i = 0; i \u0026lt; N; ++i) { cin \u0026gt;\u0026gt; A[i].first \u0026gt;\u0026gt; A[i].second; // (weight, value)... not (value, weight)  } cout \u0026lt;\u0026lt; solve(A) \u0026lt;\u0026lt; endl; return 0; }   count ways / check valid way exists  leetcode: 518 Coin Change 2\nsimilar to the previous one, but we update from weight $w_i$ to $V$\n 1 2 3 4 5 6 7 8 9 10 11  class Solution { public: int change(int t, vector\u0026lt;int\u0026gt;\u0026amp; cs) { // int dp[t + 1] = {1};  vector\u0026lt;int\u0026gt; dp(t + 1); dp[0] = 1; for (auto c : cs) for (auto j = c; j \u0026lt;= t; ++j) dp[j] += dp[j - c]; return dp[t]; } };   bounded knapsack problem description n types of goods, there are $s_i$ number of type $i$ goods and each with weight $w_i$ and value $v_i$.\nsolution to acwing: 多重背包问题 I  problem link\ntime: $O(NVlogM)$, space: $O(V)$\nreduce bounded knapsack problem to 0-1 knapsack problem\nfor type $i$ goods (M \u0026ndash; total number), split them into groups ($ceil(log_2M)$ groups) of number $1, 2, 4, 8, \u0026hellip; 2^k, M-2^k$. and treat these groups as 0-1 knapsack problem items.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; static int x = []() { std::ios::sync_with_stdio(false); cin.tie(0); return 0; }(); typedef long long ll; int N, V; int solve(vector\u0026lt;int\u0026gt; \u0026amp;weights, vector\u0026lt;int\u0026gt; \u0026amp;values, vector\u0026lt;int\u0026gt; \u0026amp;nums) { vector\u0026lt;int\u0026gt; dp(V + 1); for (int i = 0; i \u0026lt; N; ++i) { int num = min(nums[i], V / weights[i]); for (int k = 1; num; k *= 2) { if (k \u0026gt; num) k = num; num -= k; for (int j = V; j \u0026gt;= weights[i] * k; --j) { dp[j] = max(dp[j], dp[j - weights[i] * k] + values[i] * k); } } } return dp[V]; } int main(int argc, char const *argv[]) { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; // volume  vector\u0026lt;int\u0026gt; weights(N), values(N), nums(N); for (int i = 0; i \u0026lt; N; ++i) { cin \u0026gt;\u0026gt; weights[i] \u0026gt;\u0026gt; values[i] \u0026gt;\u0026gt; nums[i]; // (weight, value)... not (value, weight)  } cout \u0026lt;\u0026lt; solve(weights, values, nums) \u0026lt;\u0026lt; endl; return 0; }   more knapsack problems for exercise  leetcode : 698 Partition to K Equal Sum Subsets leetcode: 1723 Find Minimum Time to Finish All Jobs leetcode: 956 Tallest Billboard codeforces: round 699 div2, F. AB Tree \u0026ndash; bounded knapsack, greedy more as I go\u0026hellip;  refs  wiki: knapsack problem web.ntnu.edu.tw/~algo/Knapsack Problem \u0026ndash; very nice organized (written in traditional chinese) ","description":"","id":8,"section":"posts","tags":["knapsack","dp"],"title":"Knapsack Problems","uri":"https://k4i.top/en/posts/knapsack-problems/"},{"content":"The Curses library forms a wrapper over working with raw terminal codes, and provides highly flexible and efficient API (Application Programming Interface). It provides functions to move the cursor, create windows, produce colors, play with mouse etc. The application programs need not worry about the underlying terminal capabilities\ncommonly used initialization 1 2 3 4 5 6  initscr(); // init screen, first thing to to before you using ncurses cbreak(); // disable the buffering of typed characters by the TTY driver and get a character-at-a-time input noecho(); // To suppress the automatic echoing of typed characters curs_set(0); nodelay(stdscr, TRUE); // getch() return ERR if the key input is not ready endwin(); // Before the program is terminated, endwin() must be called to restore the terminal settings.   windows 1 2 3 4 5 6 7 8 9 10  keypad(stdscr, TRUE); // capture special keystrokes like Backspace, Delete and the four arrow keys by getch() // new windows int h, w; getmaxyx(stdscr, h, w); // get the size of the screen. WINDOW * win = newwin(nlines, ncols, y0, x0); // y0 and x0 are the coordinates of the upper left corner of win on the screen // Windows cannot overlap with each other. Therefore you have two options: only use stdscr and no other windows, or create several non-overlapping windows but do not use stdscr. wrefresh(win); // refresh() is equivalent to wrefresh(stdscr). delwin(win); // If a window win is no longer needed, and you\u0026#39;re going to create new windows to overlap it, you should call delwin(win) to delete the window (release the memory it is using). box derwin   input 1 2 3  wmove(win, y, x); // move(y, x) is equivalent to the wmove(stdscr, y, x). The actual cursor motion is not shown on the screen untill you do a wrefresh(win). wgetch(win); // The user input of course comes from the keyboard and not the screen window. But the different windows on the screen might have different delay modes and other properties, therefore affect the behavior of wgetch() mvwgetch(win); // mvgetch()   output 1 2 3 4 5  waddch(win, y, x, ch); // addch(); mvwaddch(); wechochar(win, ch); // waddch(win, ch); wrefresh(win); waddstr(win, str); wprintw(win, fmtstr, arg1, arg2, ...);   more add more as I go\u0026hellip;\nrefs  Ncurses Programming Guide by X. Li \u0026ndash; simple and quick NCURSES Programming HOWTO \u0026ndash; full go tui libs ","description":"","id":9,"section":"posts","tags":["TUI","curses","ncurses"],"title":"Ncurses Note","uri":"https://k4i.top/en/posts/ncurses-note/"},{"content":"Description from wiki: a disjoint-set data structure, also called a union–find data structure or merge–find set, is a data structure that stores a collection of disjoint (non-overlapping) sets\n you can easily solve leetcode: 547. Number of Provinces w/ UF.\nget UF template at github/sky-bro/AC/Algorithms/Union Find\n Template UF datastructure is very simple, it has only two key functions: U and F.\n use U (union) to connect two nodes, so they belong to the same set; use F (find) to find the root of a node (or the group id of the node)  We use ids to store the parent of every node, ids[i] is the i-th node\u0026rsquo;s parent. if ids[i] == i means i is the root if its group, we can say the group id is i.\nSo, different root/group id means nodes are in different groups, whereas same root/group id means two nodes are in the same group.\nsimle 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class UF { private: vector\u0026lt;int\u0026gt; ids; public: UF(int n) { ids.resize(n); iota(ids.begin(), ids.end(), 0); } int F(int x) { return ids[x] == x ? x : (ids[x] = F(ids[x])); } void U(int p, int q) { ids[F(p)] = ids[F(q)]; } };   full part from U and F, based on your needs, you can add these functions:\n int group_count(), count the number of sets/groups \u0026ndash; initialize group_cnt as n (each node as a group), every time U unions two different groups, --group_count. int count(int x), count the size of the group of node x \u0026ndash; when U unions two different groups, add one group\u0026rsquo;s size to another (the new root). bool connected(int p, int q), check if two nodes are in the same group.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class UF { private: vector\u0026lt;int\u0026gt; ids, cnts; int cnt; public: UF(int n) { ids.resize(n); iota(ids.begin(), ids.end(), 0); cnt = n; cnts.resize(n, 1); } int F(int x) { return ids[x] == x ? x : (ids[x] = F(ids[x])); } void U(int p, int q) { int pid = F(p), qid = F(q); if (pid != qid) { ids[qid] = pid; --cnt; cnts[pid] += cnts[qid]; } } int group_count() { return cnt; } int count(int x) { return cnts[F(x)]; } bool connected(int p, int q) { return F(p) == F(q); } };   Solution to lc problem 547  you can also solve this problem with dfs: github/sky-bro/AC/leetcode.com/0547 Friend Circles/main.cpp, lc has changed the name of this problem to \u0026ldquo;Number of Provinces\u0026rdquo;\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // union find class Solution { private: int n, cnt; vector\u0026lt;int\u0026gt; ids; void U(int p, int q) { int pid = F(p), qid = F(q); if (pid != qid) { --cnt; ids[pid] = ids[qid]; } } int F(int x) { return x == ids[x] ? x : (ids[x] = F(ids[x])); } public: int findCircleNum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; isConnected) { n = cnt = isConnected.size(); ids.resize(n); iota(ids.begin(), ids.end(), 0); for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) { if (isConnected[i][j]) { U(i, j); } } } return cnt; } };   ","description":"","id":10,"section":"posts","tags":["Union Find"],"title":"Union Find","uri":"https://k4i.top/en/posts/union-find/"},{"content":"Easily compile and use multiple glibc on a single machine.\nGet source and compile I\u0026rsquo;ll store my source at ~/src/glibc/\nyou can download sources of glibc from hit mirror, or tsinghua tuna or official\nhere take glibc-2.23 as an example, after downloading the source\n1 2 3 4 5 6 7 8 9 10 11  cd ~/src/glibc mkdir glibc-2.23-{build,out} cd glibc-2.23-build # -Wno-error will override -Werror which will make compilation fail on warnings # -O3, if you specify CFLAGS, you must give it -Ox (glibc cannot be compiled without optimization: https://gnu.org/software/libc/manual/html_mono/libc.html#toc-Installing-the-GNU-C-Library) # -g will generate embed debug information ../glibc-2.23/configure --prefix=~/src/glibc/glibc-2.23-out CFLAGS=\u0026#34;-Wno-error -O3 -g\u0026#34; # this is important # make # compile with single thread, slow: took me about 14 minutes make -j`nproc` # faster: took me under 2 minutes # make -j$((`nproc`+1)) # https://unix.stackexchange.com/questions/208568/how-to-determine-the-maximum-number-to-pass-to-make-j-option make install # install to what you have configured in the `--prefix` (so mine will be installed to ~/src/glibc/glibc-2.23-out)   use mgcc to compile programs mgcc mgcc is just a shell wrapper that wraps the gcc command, you can compile programs same way as you would in gcc.\nyou can also specify --glibc_install with the installation path of some version of glibc to switch between different glibc\u0026rsquo;s: mgcc --glibc_install ~/src/glibc/glibc-2.32-out -g -o main main.c\nYou can find my most up to date mgcc at .dotfiles/bin/mgcc\nvim ~/bin/mgcc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #!/bin/sh  glibc_install=~/src/glibc/glibc-2.23-out print_help() { echo \u0026#34;$0[--glibc_install GLIBC_INSTALL_PATH] gcc_args\u0026#34; } while [[ $# -ge 1 ]] do key=\u0026#34;$1\u0026#34; case $key in --glibc_install) glibc_install=\u0026#34;$2\u0026#34; shift ;; -h) print_help exit 0 ;; *) others+=(\u0026#34;$1\u0026#34;) ;; esac shift done gcc \\  -L \u0026#34;${glibc_install}/lib\u0026#34; \\  -I \u0026#34;${glibc_install}/include\u0026#34; \\  -Wl,--rpath=\u0026#34;${glibc_install}/lib\u0026#34; \\  -Wl,--dynamic-linker=\u0026#34;${glibc_install}/lib/ld-linux-x86-64.so.2\u0026#34; \\  \u0026#34;${others[@]}\u0026#34;   run \u0026amp; debug vim main.c\n1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main(int argc, char const *argv[]) { void *p1 = malloc(0x70); void *p2 = malloc(0x70); free(p1); free(p2); free(p1); return 0; }   you can check if your mgcc works after compile mgcc -g -o main main.c:\n1 2 3 4  ldd main # linux-vdso.so.1 (0x00007ffd36f9a000) # libc.so.6 =\u0026gt; /home/sky/src/glibc/glibc-2.23-out/lib/libc.so.6 (0x00007fac09658000) # /home/sky/src/glibc/glibc-2.23-out/lib/ld-linux-x86-64.so.2 =\u0026gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007fac0981b000)   tell gdb where to look for source code: dir ~/src/glibc/glibc-2.23/malloc\n1 2 3 4  gdb main # ... pwndbg\u0026gt; dir ~/src/glibc/glibc-2.23/malloc/ # ...    you can see malloc source code in gdb\n  completion if you are using zsh and oh-my-zsh (you should), you can add a line: compdef mgcc=gcc to your ~/.zshrc file\nthis will allow mgcc to use gcc\u0026rsquo;s completion\nrun others' program with your libc CLI 1 2 3  LD_PRELOAD=./libc.so ./program # or https://pullp.github.io/2020/11/06/11-glibc-basics/#2-2-run-with-specific-glibc LD_PRELOAD=./libc.so ./ld.so ./program   pwntools 1 2 3 4 5  #coding:utf-8 from pwn import * io = process(\u0026#34;./program\u0026#34;, env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;./libc.so\u0026#34;}) io = process([\u0026#34;./ld.so\u0026#34;, \u0026#34;./program\u0026#34;], env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;./libc.so\u0026#34;})   refs  glibc相关操作记录 How to determine the maximum number to pass to make -j option? offcial: glibc installation guide How can I link to a specific glibc version? ","description":"","id":11,"section":"posts","tags":["glibc","pwng","gcc"],"title":"Compile and Use Your Own Glibc","uri":"https://k4i.top/en/posts/compile-and-use-your-own-glibc/"},{"content":"portable \u0026amp; minimal tmux configuration, with cheetsheet\n.tmux.conf My most up to date config file is at github: .dotfiles/.tmux.conf, and for better experience, I strongly suggest you use Capslock as your Ctrl key.\n# chenge prefix from `C-b` to `C-a` set -g prefix C-a unbind C-b bind C-a send-prefix # better window split, with \u0026quot;-\u0026quot; and \u0026quot;|\u0026quot; unbind '\u0026quot;' bind - splitw -v -c '#{pane_current_path}' unbind % bind | splitw -h -c '#{pane_current_path}' # enable mouse set-option -g mouse on # use hjkl to # change focus bind -r k select-pane -U bind -r j select-pane -D bind -r h select-pane -L bind -r l select-pane -R # resize pane bind -r ^k resizep -U 2 # upward (prefix Ctrl+k) bind -r ^j resizep -D 2 # downward (prefix Ctrl+j) bind -r ^h resizep -L 2 # to the left (prefix Ctrl+h) bind -r ^l resizep -R 2 # to the right (prefix Ctrl+l) # enable vi motions setw -g mode-keys vi # select, copy with v, y bind -T copy-mode-vi v send-keys -X begin-selection bind -T copy-mode-vi y send-keys -X copy-selection-and-cancel set -g base-index 1 set -g pane-base-index 1 set -g status-interval 1 set -g status-justify left setw -g monitor-activity on # Set default term to xterm # https://github.com/zsh-users/zsh-autosuggestions/issues/229 # https://stackoverflow.com/questions/18600188/home-end-keys-do-not-work-in-tmux set -g default-terminal screen-256color Most useful shortcuts \u0026amp; cheetsheet  prefix means C-b by default, or C-a for me\nlist all shortcuts: prefix ?\n sessions  list session: tmux ls, prefix s new session: tmux new -s session_name (attach now), tmux new -d session_name (do not attach) attach session: tmux a -t session_name rename session: prefix $ kill session: tmux kill-session -t session_name  windows  new window: prefix c next window: prefix n previous window: prefix p rename window: prefix , kill window: prefix \u0026amp;  panes  change focus between panes: prefix h/j/k/l resize pane: prefix C-h/j/k/l split pane: prefix | vsplit pane: prefix - toggle zoom: prefix z kill pane: prefix x scroll pane: use mouse wheel or prefix [ then with vi motions  copy \u0026amp; paste  within tmux  select \u0026amp; copy with your mouse or first enter navigation: prefix [, then  navigate with vi motions: hjkl, C-f, C-b, \u0026hellip; v or shift+v to start character/line level selection o to change active end of selection y to yank (copy) or q to quit navigation prefix ] to paste selection     bettwen tmux and your host  hold shift and use mouse to select copy with Ctrl+Shift+c or Ctrl+c paste with Ctrl+Shift+v or Ctrl+v   ","description":"","id":12,"section":"posts","tags":["tmux","cheetsheet"],"title":"Tmux Basics","uri":"https://k4i.top/en/posts/tmux-basics/"},{"content":"setup hypervisor with qemu and kvm, the best linux based open source virtualization solution\nKVM is part of linux kernel, and QEMU (Quick EMUlator) is an emulator. KVM by itself cannot provide the complete virtualization solution, it needs QEMU to provide full hypervisor functionality. QEMU can emulate cpu on its own, but with KVM, QEMU can achieve near native performance by executing the guest code directly on the host CPU.\nSo it\u0026rsquo;s best for them to work together.\ntools you need Use your own package manager to install these tools:\n1 2 3 4 5 6 7 8 9  # I\u0026#39;m using arch, so... sudo pacman -Sy --needed \\  qemu \\  virt-viewer \\  libvirt \\  dnsmasq \\  ebtables \\  virt-install \\  virt-manager \\    kvm (Kernel-based Virtual Machine): Kernel module that handles CPU and memory communication qemu (Quick EMUlator): emulates many hardware resources \u0026ndash; dick, network, usb\u0026hellip; libvirt: an open-source API, daemon and management tool for managing platform virtualization. It can be used to manage KVM, Xen, VMware ESXi, QEMU and other virtualization technologies. virsh: Command-line tools for communicating with libvirt virt-manager: GUI alternative to virsh, albeit less capable. virt-viewer: part of virt-manager project, create new VM guests virt-install: part of virt-manager project, UI for interacting with VMs via VNC/SPICE dnsmasq: light-weight DNS/DHCP server. Primarily used for allocating IPs to VMs. ebtables: used for setting up NAT networking the host  some setup two problems\n by default, virt-manager talks to qemu:///system, and virsh talks to qemu:///session (unless run as sudo). when talking to qemu:///system, we need to input password every time, especially unpleasant experience when a cli tool like virsh.  For the first problem, we can tell virsh to use qemu:///system by default\n1 2  cp /etc/libvirt/libvirt.conf ~/.config/libvirt/libvirt.conf vim ~/.config/libvirt/libvirt.conf # uncomment or add: uri_default = \u0026#34;qemu:///system\u0026#34;   To solve the second problem, we can add a rule to polkit to allow our group (wheel \u0026ndash; administrator group) to use virt-manager or vish without being asked for password.\nedit /etc/polkit-1/rules.d/xxx.rules, your path may be different.\n/* Allow users in wheel group to manage the libvirt daemon without authentication */ polkit.addRule(function(action, subject) { if (action.id == \u0026quot;org.libvirt.unix.manage\u0026quot; \u0026amp;\u0026amp; subject.isInGroup(\u0026quot;wheel\u0026quot;)) { return polkit.Result.YES; } }); start services 1 2 3 4  systemctl enable libvirtd # start on boot systemctl start libvirtd # start libvirtd virsh net-autostart --network default virsh net-start --network default # start the default network   add shrarefolders in virtual machine manager, double click on one of your machine, then select view-\u0026gt;details-\u0026gt;Add Hardware, set something like below:\nThe above setting will add a new device /ctf in the virtual machine\nif in ubuntu sudo vim /etc/rc.local\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #!/bin/sh -e # # rc.local # # This script is executed at the end of each multiuser runlevel. # Make sure that the script will \u0026#34;exit 0\u0026#34; on success or any other # value on error. # # In order to enable or disable this script just change the execution # bits. # # By default this script does nothing. mount -t 9p -o trans=virtio,version=9p2000.L /ctf /home/sky/ctf exit 0   after restart this server, /ctf will automatically be mounted on /home/sky/ctf\nto make the user (actually kvm) writing the share folder same as the user at host (vm host):\nsudo vim /etc/libvirt/qemu.conf, find two lines with user=\u0026quot;xxx\u0026quot; and group=\u0026quot;xxx\u0026quot;, change them to yourself (by default, xxx should be root), then uncomment the two lines. for me, they are:\n1 2  user = \u0026#34;sky\u0026#34; group = \u0026#34;sky\u0026#34;   You may need to restart the libvirtd.service for this to take effect.\nAlso, you need to chown the disk to the above user:group: sudo chown sky:sky /var/lib/libvirt/images/ubt16-server.qcow2\ncreate a VM clone a VM useful virsh commands","description":"","id":13,"section":"posts","tags":["hypervisor","kvm","qemu"],"title":"Linux Hypervisor Setup","uri":"https://k4i.top/en/posts/linux-hypervisor-setup/"},{"content":"Create new post First you need to create a file for you to write. Here\u0026rsquo;s how you can create a new post:\n1 2 3 4  hugo new posts/writing-guide.md # will create content/en/posts/writing-guide.md, \u0026#39;en\u0026#39; is set as my site\u0026#39;s default language hugo new posts/writing-guide.zh.md # content/zh/posts/writing-guide.zh.md hugo new posts/writing-guide/index.md # content/en/posts/writing-guide/index.md hugo new posts/writing-guide/index.zh.md # content/en/posts/writing-guide/index.zh.md   I prefer to create a directory for each of my writings, so I can add extra stuff like images for that specific page more easily.\nCode you can write multi-lines of code\n1 2 3 4 5 6 7 8 9 10  ````markdown # markdown code example keep nesting with different # of ticks (the more to the outside, the more ticks) ```markdown ## some header  * list item1 * list item2 ``` ````   Pictures 1 2  \u0026lt;!-- no caption by default --\u0026gt; ![an image in this directory](./images/scott.jpg)   1 2 3  \u0026lt;!-- better way, use figure shortcode --\u0026gt; \u0026lt;!-- to know more shortcodes: https://gohugo.io/content-management/shortcodes/ --\u0026gt; {{\u0026lt; figure src=\u0026#34;./images/scott.jpg\u0026#34; caption=\u0026#34;an image in this directory (this is Scott Adkins)\u0026#34; alt=\u0026#34;an image in this directory\u0026#34; \u0026gt;}}    an image in this directory (this is Scott Adkins)\n  Math Support (with MathJax) You can get some quick examples from: typora\u0026rsquo;s doc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  single \\\\$ for inline code: $x,y,z$ two \\\\$\u0026#39;s for block level code: $$z = \\sqrt{x^2 + y^2}$$ $$ \\begin{align*} y = y(x,t) \u0026amp;= A e^{i\\theta} \\\\\\\\ \u0026amp;= A (\\cos \\theta + i \\sin \\theta) \\\\\\\\ \u0026amp;= A (\\cos(kx - \\omega t) + i \\sin(kx - \\omega t)) \\\\\\\\ \u0026amp;= A\\cos(kx - \\omega t) + i A\\sin(kx - \\omega t) \\\\\\\\ \u0026amp;= A\\cos \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) + i A\\sin \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) \\\\\\\\ \u0026amp;= A\\cos \\frac{2\\pi}{\\lambda} (x - v t) + i A\\sin \\frac{2\\pi}{\\lambda} (x - v t) \\end{align*} $$   single \\$ for inline code: $x,y,z$\ntwo \\$\u0026rsquo;s for block level code:\n$$z = \\sqrt{x^2 + y^2}$$\n$$\n\\begin{align*}\ny = y(x,t) \u0026amp;= A e^{i\\theta} \\\\\n\u0026amp;= A (\\cos \\theta + i \\sin \\theta) \\\\\n\u0026amp;= A (\\cos(kx - \\omega t) + i \\sin(kx - \\omega t)) \\\\\n\u0026amp;= A\\cos(kx - \\omega t) + i A\\sin(kx - \\omega t) \\\\\n\u0026amp;= A\\cos \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) + i A\\sin \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) \\\\\n\u0026amp;= A\\cos \\frac{2\\pi}{\\lambda} (x - v t) + i A\\sin \\frac{2\\pi}{\\lambda} (x - v t)\n\\end{align*}\n$$\nFlow charts TODO\nMore To be added\u0026hellip;\n","description":"Guides on how to wirte your contents using this theme (my cheetsheet).","id":14,"section":"posts","tags":[""],"title":"Writing Guide","uri":"https://k4i.top/en/posts/writing-guide/"},{"content":"Basic  password for user \u0026ldquo;bandit0\u0026rdquo; is \u0026ldquo;bandit0\u0026rdquo; ssh into the next host, e.g: ssh -p2220 bandit0@bandit.labs.overthewire.org find password for next level goto step 2  Tricks  hit \u0026lt;TAB\u0026gt; for command completion ls -a to show hidden files (names started with .) find command man command (man file)  Answers  level0 (password found: bandit0) level0-\u0026gt;level1: cat ./readme (password found: boJ9jbbUNNfktd78OOpsqOltutMc3MY1) level1-\u0026gt;level2: cat ./- (password found: CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9) level2-\u0026gt;level3: cat ./spaces\\ in\\ this\\ filename (password found: UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK) level3-\u0026gt;level4: ls -a ./inhere; cat ./inhere/.hidden (password found: pIwrPrtPN36QITSp3EQaw936yaFoFgAB) level4-\u0026gt;level5: file ./inhere/*; cat ./inhere/-file07 (password found: koReBOKuIDDepwhWk7jZC0RTdopnAYKh) level5-\u0026gt;level6: find ./ -size 1033c \\! -executable -readable; cat ./inhere/mabehere07/.file2 (password found: DXjZPULLxYr17uwoI01bNLQbtFemEgo7) level6-\u0026gt;level7: find / -size 33c -user bandit7 -group bandit6; cat /var/lib/dpkg/info/bandit7.password (password found: HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs) level7-\u0026gt;level8: grep millionth (password found: cvX2JJa4CFALtqS87jk27qwqGhBM9plV) level8-\u0026gt;level9: sort data.txt | uniq -u (password found: UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR) level9-\u0026gt;level10: strings data.txt | grep \u0026quot;===\u0026quot; (password found: truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk) level10-\u0026gt;level11: base64 -d data.txt (password found: IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR) level11-\u0026gt;level12: cat data.txt | tr \u0026quot;a-zA-Z\u0026quot; \u0026quot;n-za-mN-ZA-M\u0026quot; (password found: 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu) level12-\u0026gt;level13: xxd -r data.txt \u0026gt; data; file data; ... (password found: 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL) level13-\u0026gt;level14: ssh -i sshkey.private bandit14@localhost (password found: 4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e) level14-\u0026gt;level15: nc localhost 30000 (password found: BfMYroe26WYalil77FoDi9qh59eK5xNr) level15-\u0026gt;level16: nc localhost 30000 (password found: BfMYroe26WYalil77FoDi9qh59eK5xNr) https://overthewire.org/wargames/bandit/bandit16.html  ","description":"my solutions to the bandit wargame: https://overthewire.org/wargames/bandit/","id":15,"section":"posts","tags":["wargames"],"title":"Wargames Bandit","uri":"https://k4i.top/en/posts/wargames-bandit/"},{"content":"A de Bruijn sequence of order n on a size-k alphabet A is a cyclic sequence in which every possible length-n string on A occurs exactly once as a substring.\nFor a de Bruijn sequence of order n on a size-k alphabet $A$, we denote it by $B(k, n)$\nBasic Properties  $B(k, n)$ has length $k^n$ (also the number of distinct strings of length n on A) De Bruijn sequences are optimally short with respect to the property of containing every string of length n exactly once The number of distinct de Bruijn sequences $B(k, n)$ is\n$$\\frac{(k!)^{k^{n-1}}}{k^n}$$  An Example Sequence let\u0026rsquo;s use $B(2, 4)$ as an example\nSequence 0000111101100101 (cyclic sequcence) belongs to $B(2,4)$.\nIt contains every string of length n exactly once:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  {0 0 0 0} 1 1 1 1 0 1 1 0 0 1 0 1 0 {0 0 0 1} 1 1 1 0 1 1 0 0 1 0 1 0 0 {0 0 1 1} 1 1 0 1 1 0 0 1 0 1 0 0 0 {0 1 1 1} 1 0 1 1 0 0 1 0 1 0 0 0 0 {1 1 1 1} 0 1 1 0 0 1 0 1 0 0 0 0 1 {1 1 1 0} 1 1 0 0 1 0 1 0 0 0 0 1 1 {1 1 0 1} 1 0 0 1 0 1 0 0 0 0 1 1 1 {1 0 1 1} 0 0 1 0 1 0 0 0 0 1 1 1 1 {0 1 1 0} 0 1 0 1 0 0 0 0 1 1 1 1 0 {1 1 0 0} 1 0 1 0 0 0 0 1 1 1 1 0 1 {1 0 0 1} 0 1 0 0 0 0 1 1 1 1 0 1 1 {0 0 1 0} 1 0 0 0 0 1 1 1 1 0 1 1 0 {0 1 0 1} 0} 0 0 0 1 1 1 1 0 1 1 0 0 {1 0 1 ... ... 0 0} 0 0 1 1 1 1 0 1 1 0 0 1 {0 1 ... ... 0 0 0} 0 1 1 1 1 0 1 1 0 0 1 0 {1 ...   How to Construct the Sequence Can be constructed by taking an Eulerian cycle of an (n − 1)-dimensional de Bruijn graph: (Hierholzer’s Algorithm)\n A de Bruijn graph\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  // copied from geeksforgeeks #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; unordered_set\u0026lt;string\u0026gt; seen; vector\u0026lt;int\u0026gt; edges; // Modified DFS in which no edge // is traversed twice void dfs(string node, int\u0026amp; k, string\u0026amp; A) { for (int i = 0; i \u0026lt; k; ++i) { string str = node + A[i]; if (seen.find(str) == seen.end()) { seen.insert(str); dfs(str.substr(1), k, A); edges.push_back(i); } } } // Function to find a de Bruijn sequence // of order n on k characters string deBruijn(int n, int k, string A) { // Clearing global variables  seen.clear(); edges.clear(); string startingNode = string(n - 1, A[0]); dfs(startingNode, k, A); string S; // Number of edges  int l = pow(k, n); for (int i = 0; i \u0026lt; l; ++i) S += A[edges[i]]; S += startingNode; return S; } // Driver code int main() { int n = 3, k = 2; string A = \u0026#34;01\u0026#34;; cout \u0026lt;\u0026lt; deBruijn(n, k, A); return 0; }   Related Problems   leetcode 753: Cracking the Safe\nexample solution from leetcode discuss\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { int n, k, v; vector\u0026lt;vector\u0026lt;bool\u0026gt; \u0026gt; visited; string sequence; public: string crackSafe(int n, int k) { if (k == 1) return string(n, \u0026#39;0\u0026#39;); this-\u0026gt;n = n; this-\u0026gt;k = k; v = 1; for (int i = 0; i \u0026lt; n - 1; ++i) v *= k; visited.resize(v, vector\u0026lt;bool\u0026gt;(k, false)); dfs(0); return sequence + sequence.substr(0, n - 1); } void dfs(int u) { for (int i = 0; i \u0026lt; k; ++i) { if (!visited[u][i]) { visited[u][i] = true; dfs((u * k + i) % v); sequence.push_back(\u0026#39;0\u0026#39; + i); } } } };     Refs  wiki: De Bruijn sequence geeksforgeeks: De Bruijn sequence | Set 1 ","description":"","id":16,"section":"posts","tags":["math","dfs"],"title":"De Bruijn Sequence","uri":"https://k4i.top/en/posts/de-bruijn-sequence/"},{"content":"Old way use rand(), usually pair with a random initialization of the seed:\n1 2  srand(int(time(0))); // initialize the seed rand(); // get a random int, [0, RAND_MAX]   get random int in [0,x): rand()%x\nget random real in [0, 1]: rand()/double(RAND_MAX)\nModern way 1 2 3 4 5  // ... #include \u0026lt;random\u0026gt; std::random_device rng; std::mt19937 urng(rng());   random_device random_device is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\nA good implementation should has its randomness come from a non-deterministic source (e.g. a hardware device).\nWe can just use this to get our random numbers, but it might come with a light performance price. A PRNG is much better\npseudo RNG So, we usually use random_device to get our first random number, then use it to initialize other PRNGs, then we can more quickly get many more random numbers.\nThe STL implements several PRNGs (see cppref: Predefined random number generators), not just the Mersenne Twister shown above, you can check\nUse cases of PRNG TODO\u0026hellip;\nRefs  cppref: std::random_device cppref: Predefined random number generators std::random_shuffle is deprecated in C++14  ","description":"introduce randomness into your C++ programs, the right way.","id":17,"section":"posts","tags":["RNG","C++","Random","STL"],"title":"Use Random in C++","uri":"https://k4i.top/en/posts/use-random-in-c++/"},{"content":"Yes, by default I heard before that using scanf/printf is faster than using cin/cout, and it\u0026rsquo;s true from my real experience, but I really didn\u0026rsquo;t get to know the reason behind, and later in leetcode, I saw others include these lines in their code:\n1 2 3  ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);   I\u0026rsquo;m almost certain that these lines are included to speed up their code. So out of curiosity, I did some searching, here\u0026rsquo;s what I\u0026rsquo;ve found:\nWhy cin \u0026amp; cout is slow First Reason: unbuffered streams By default, C++ streams are synchronized to the standard C streams after each input/output operation, meaning that C++ streams are unbuffered, each I/O operation on a C++ stream is immediately applied to the corresponding C stream\u0026rsquo;s buffer.\nSo this is the main reaseon: To be compatible with C (so you can mix your C code inside C++), C++ do not buffer its streams.\nSecond Reason: cin, cout streams are tied together By default, cin is tied to cout, and wcin to wcout, guarantees the flushing of cout before cin executes an input. In pure C, you may have to guarantee this by manually using fflush after the printf.\nWhat these three lines do ios::sync_with_stdio(false) As said above, by default c++ streams share c streams' buffers. This can be tweeked using the ios::sync_with_stdio(bool sync = true) function. After setting the sychronization to false, the synchronization between the C and C++ standard streams is disabled, C++ will use its own buffer.\ncin.tie(NULL) \u0026amp; cout.tie(NULL) tie is used to tie a stream (in/out) to some output stream, if the parameter is NULL, untie this stream from any tied stream (returns previous tied stream)\nif called without any argument, return the tied stream:\n1  *cin.tie() \u0026lt;\u0026lt; 123; // same as cout \u0026lt;\u0026lt; 123; (by default, cin is tied to cout)   so this is just used to untie cin/cout from any tied output stream (normally we just need to use cin.tie(0)), then the previously tied output stream won\u0026rsquo;t be forced to flush.\nWhen should I use the \u0026ldquo;speed up\u0026rdquo; Know the adventures   If you disable the synchronization, then C++ streams are allowed to have their own independent buffers, which makes mixing C- and C++-style I/O an adventure. Also, synchronized C++ streams are thread-safe (output from different threads may interleave, but you get no data races). (refer cppref)\n  If you untie cin, then later when you execute the lines below, you won\u0026rsquo;t be guaranteed to see the prompt before the input request from cin.\n  1 2 3  string name; cout \u0026lt;\u0026lt; \u0026#34;Please input your name:\u0026#34;; cin \u0026gt;\u0026gt; name;   Decide If you do not mix use the C- and C++-style I/O, do not write multi-thread program, use ios::sync_with_stdio(false).\nIf you do not care about seeing some output before your input, use tie(0).\nExample 1 2 3 4 5  int main() { // ... } static int x = []() {ios::sync_with_stdio(false); cin.tie(0); return 0; } ();   Refs  cppref: std::ios_base::sync_with_stdio cppref: std::basic_ios\u0026lt;CharT,Traits\u0026gt;::tie Why do we need to tie std::cin and std::cout?  ","description":"is or why is cin, cout slow in C++?","id":18,"section":"posts","tags":["C++"],"title":"cin \u0026 cout is slow?","uri":"https://k4i.top/en/posts/cin-cout-is-slow/"},{"content":"A segment tree is a binary tree where each node represents an interval. Each node stores some property of its corresponding interval: like the maximum/minimum num, the sum of that interval.\nApplicable Problems For any array a, where every element belongs to some monoid $(S, \\oplus)$ we can build a segment tree to answer the following queries (problems):\n– Get(l, r) — returns $a_l \\oplus a_{l+1} \\oplus \\dotsb a_r$\n– Change(p, x) — set $a_p = x$\n Monoids are semigroups with identity. $\\oplus$ is an associative binary operation. Identity element for some pair $(S, \\oplus)$ is such an element $e \\in S$ that for every $a \\in S$ condition $a ⊕ e = e \\oplus a = a$ holds;   Example Problem leetcode 307: Range Sum Query - Mutable\nGiven an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.\nThe update(i, val) function modifies nums by updating the element at index i to val. For this problem, the identity element is 0, and the binary operation is + between integers.\nAnd for simplicity we use the identity element to extend the length of the original array to some integer power of 2.\n Padded Segment Tree\n  if size of the array is n, then we only need an array of 2*n length to store the segment tree. (only in iterative version, property of a Complete Binary Tree)\n Segment Tree Built Iteratively\n  Define the binary operation Here we will just use + for our operation, you can if you need define a merge function for your special operation $\\oplus$.\n1 2 3  inline int merge(int a, int b) { return a + b; }   Build the Tree We want to construct an array like above (the original array is {1, 2, 3, 4, 5, 6}), the essential idea of a segment tree is that a node at index $i$ (index starts from 1, you can also try starting from 0, but starting from 1 is simpler) can have two children at indexes $(2 \\ast i)$ and $(2 \\ast i + 1)$.\n1 2 3 4 5 6 7 8 9 10  NumArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { n = nums.size(); segment_tree.resize(2 * n); for (int i = 0; i \u0026lt; n; ++i) { segment_tree[i + n] = nums[i]; } for (int i = n - 1; i \u0026gt; 0; --i) { segment_tree[i] = segment_tree[i\u0026lt;\u0026lt;1] + segment_tree[i\u0026lt;\u0026lt;1|1]; } }   Query a range sum 1 2 3 4 5 6 7 8  int sumRange(int i, int j) { // sum range [i, j]  int sum = 0; for (i += n, j += n+1; i \u0026lt; j; i \u0026gt;\u0026gt;= 1, j \u0026gt;\u0026gt;= 1) { if (i\u0026amp;1) sum += segment_tree[i++]; if (j\u0026amp;1) sum += segment_tree[--j]; } return sum; }   Update an element/elements 1 2 3 4 5 6 7  void update(int i, int val) { i += n; if (segment_tree[i] == val) return; for (segment_tree[i] = val; i \u0026gt; 1; i \u0026gt;\u0026gt;= 1) { segment_tree[i\u0026gt;\u0026gt;1] = segment_tree[i] + segment_tree[i^1]; } }   Complete Solution to the Problem   Leetcode 307 Solution (C\u0026#43;\u0026#43;)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class NumArray { private: int n; vector\u0026lt;int\u0026gt; segment_tree; public: NumArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { n = nums.size(); segment_tree.resize(2*n); for (int i = 0; i \u0026lt; n; ++i) { segment_tree[i+n] = nums[i]; } for (int i = n-1; i \u0026gt; 0; --i) { segment_tree[i] = segment_tree[i\u0026lt;\u0026lt;1] + segment_tree[i\u0026lt;\u0026lt;1|1]; } } void update(int i, int val) { i += n; if (segment_tree[i] == val) return; for (segment_tree[i] = val; i \u0026gt; 1; i \u0026gt;\u0026gt;= 1) { segment_tree[i\u0026gt;\u0026gt;1] = segment_tree[i] + segment_tree[i^1]; } } int sumRange(int i, int j) { // sum range [i, j]  int sum = 0; for (i += n, j += n+1; i \u0026lt; j; i \u0026gt;\u0026gt;= 1, j \u0026gt;\u0026gt;= 1) { if (i\u0026amp;1) sum += segment_tree[i++]; if (j\u0026amp;1) sum += segment_tree[--j]; } return sum; } };      Refs  youtube: Efficient Segment Tree Tutorial codeforces: Efficient and easy segment trees: best Segment tree Theory and applications wiki: binary tree - in an array ","description":"","id":19,"section":"posts","tags":["segment tree"],"title":"Segment Tree (Iterative)","uri":"https://k4i.top/en/posts/segment-tree-iterative/"},{"content":"let\u0026rsquo;s learn how to use heap in C++\nRelated functions    func description     make_heap Make heap from range   push_heap Push element into heap range   pop_heap Pop element from heap range   sort_heap Sort elements of heap   is_heap Test if range is heap   is_heap_until Find first element not in heap order    make_heap  make heap from range\n We need to have a heap before we operate on a heap, make_heap let\u0026rsquo;s us rearrange elements in a range.\nUsually we use a vector to hold these range of elements:\n1 2 3 4 5 6  #include \u0026lt;iostream\u0026gt; // std::cout#include \u0026lt;algorithm\u0026gt; // std::make_heap, std::pop_heap, std::push_heap, std::sort_heap#include \u0026lt;vector\u0026gt; // std::vector std::vector\u0026lt;int\u0026gt; heap{1,2,3,4,5,6,7}; std::make_heap(heap.begin(), heap.end()); // 7 5 6 4 2 1 3   For now, you only need to know that after make_heap, the biggest element is *begin(heap) or heap[0]. Other elements are not necessarily sorted, but arranged in a certain way, to know the detail, see heap in C++ 2.\npush_heap  Push element into heap range\n Given a heap in the range [first,last-1), this function extends the range considered a heap to [first,last) by placing the value in (last-1) into its corresponding location within it.\nMeaning to add an element to a heap:\n1 2  heap.push_back(8); // 7 5 6 4 2 1 3 8 std::push_heap(heap.begin(), heap.end()); // 8 7 6 5 2 1 3 4   push_heap will adjust the elements in the new range (old range + 1), and place the added element to where it fits.\npop_heap  Pop element from heap range\n Given a heap in the range [first,last), this function rearranges the elements in the heap range [first,last) in such a way that the part considered a heap is shortened by one: The element with the highest value is moved to (last-1).\nMeaning to pop out the largest element from the heap:\n1  std::pop_heap(heap.begin(), heap.end()); // 7 5 6 4 2 1 3 8   new heap range: [first, last-1)\nis_heap  Test if range is heap\n simple as description, code:\n1 2 3  // heap: 7 5 6 4 2 1 3 8 std::is_heap(heap.begin(), heap.end()); // false std::is_heap(heap.begin(), heap.end()-1); // true   is_heap_until  Find first element not in heap order\n We\u0026rsquo;ve already popped out 8 from the heap, so:\n1 2 3  // 7 5 6 4 2 1 3 8 auto it = std::is_heap_until(heap.begin(), heap.end()); std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; // 8   sort_heap  Sort elements of heap\n Sorts the elements in the heap range [first,last) into ascending order.\nThis is actually quite simple, you may have as well implement this function yourself, just keep doing pop_heap until the heap is shortened to 1.\n1  std::sort_heap(heap.begin(), heap.end() - 1, cmp); // 1 2 3 4 5 6 7 8   Code Examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  #include \u0026lt;algorithm\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;random\u0026gt;#include \u0026lt;vector\u0026gt; template \u0026lt;typename T\u0026gt; void printArr(const std::vector\u0026lt;T\u0026gt; \u0026amp;arr) { for (const T \u0026amp;t : arr) std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34; \u0026#34;; std::cout \u0026lt;\u0026lt; std::endl; } // std::random_device rd; // std::mt19937_64 urng(rd());  int main(int argc, char const *argv[]) { std::cout \u0026lt;\u0026lt; \u0026#34;original array\u0026#34; \u0026lt;\u0026lt; std::endl; std::vector\u0026lt;int\u0026gt; heap(7); std::iota(heap.begin(), heap.end(), 1); printArr(heap); // 1 2 3 4 5 6 7  // std::cout \u0026lt;\u0026lt; \u0026#34;shuffle\u0026#34; \u0026lt;\u0026lt; std::endl;  // std::shuffle(heap.begin(), heap.end(), urng);  // printArr(heap);  // auto cmp = std::greater\u0026lt;int\u0026gt;();  // auto cmp = std::less\u0026lt;int\u0026gt;();  std::cout \u0026lt;\u0026lt; \u0026#34;make heap\u0026#34; \u0026lt;\u0026lt; std::endl; std::make_heap(heap.begin(), heap.end()); printArr(heap); // 7 5 6 4 2 1 3  std::cout \u0026lt;\u0026lt; \u0026#34;push back 8\u0026#34; \u0026lt;\u0026lt; std::endl; heap.push_back(8); printArr(heap); // 7 5 6 4 2 1 3 8  std::cout \u0026lt;\u0026lt; \u0026#34;push heap\u0026#34; \u0026lt;\u0026lt; std::endl; std::push_heap(heap.begin(), heap.end()); printArr(heap); // 8 7 6 5 2 1 3 4  std::cout \u0026lt;\u0026lt; \u0026#34;pop heap\u0026#34; \u0026lt;\u0026lt; std::endl; std::pop_heap(heap.begin(), heap.end()); printArr(heap); // 7 5 6 4 2 1 3 8  std::cout \u0026lt;\u0026lt; \u0026#34;is heap\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::is_heap(heap.begin(), heap.end()) \u0026lt;\u0026lt; std::endl; // 0  std::cout \u0026lt;\u0026lt; \u0026#34;is heap until\u0026#34; \u0026lt;\u0026lt; std::endl; auto it = std::is_heap_until(heap.begin(), heap.end()); std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; // 8  std::cout \u0026lt;\u0026lt; \u0026#34;sort heap (begin, end-1)\u0026#34; \u0026lt;\u0026lt; std::endl; std::sort_heap(heap.begin(), heap.end() - 1); printArr(heap); // 1 2 3 4 5 6 7 8  return 0; }   Refs  cplusplus.com: see heap algorithms  ","description":"learn how to use heap in C++","id":20,"section":"posts","tags":["C++","heap"],"title":"Heap in C++","uri":"https://k4i.top/en/posts/heap-in-c++/"},{"content":"🚩 This Site Generated using Hugo，source code here: blog-src, and the theme is forked (my fork) from: hugo-theme-zzo\n🌅 Daily Life  @HIT C / C++, Python, ASM Arch, VSCode CTF / Binary  💌 Contact Me  Email: sky_io@outlook.com WeChat: sky_bro Facebook: Kaiyu Shi Twitter: KaiyuShi GPG Pub: Kyle.asc (F4CD 0E4A 3661 65D1 62E6 B6CE 7D36 AE60 55B0 60A6)  🐔 My Friends TheSong, 路人枭, wxk\n🎼 Listening recently \n","description":"About Kyle Shi / sky / Kaiyu Shi, whoami, I am an enthusiast!","id":21,"section":"","tags":null,"title":"About","uri":"https://k4i.top/en/about/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":22,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://k4i.top/en/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":23,"section":"gallery","tags":null,"title":"Photo","uri":"https://k4i.top/en/gallery/photo/"}]