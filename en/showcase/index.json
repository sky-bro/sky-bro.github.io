[{"content":"portable \u0026amp; minimal tmux configuration, with cheetsheet\n.tmux.conf My most up to date config file is at github: .dotfiles/.tmux.conf, and for better experience, I strongly suggest you use Capslock as your Ctrl key.\n# chenge prefix from `C-b` to `C-a` set -g prefix C-a unbind C-b bind C-a send-prefix # better window split, with \u0026quot;-\u0026quot; and \u0026quot;|\u0026quot; unbind '\u0026quot;' bind - splitw -v -c '#{pane_current_path}' unbind % bind | splitw -h -c '#{pane_current_path}' # enable mouse set-option -g mouse on # use hjkl to # change focus bind -r k select-pane -U bind -r j select-pane -D bind -r h select-pane -L bind -r l select-pane -R # resize pane bind -r ^k resizep -U 2 # upward (prefix Ctrl+k) bind -r ^j resizep -D 2 # downward (prefix Ctrl+j) bind -r ^h resizep -L 2 # to the left (prefix Ctrl+h) bind -r ^l resizep -R 2 # to the right (prefix Ctrl+l) # enable vi motions setw -g mode-keys vi # select, copy with v, y bind -T copy-mode-vi v send-keys -X begin-selection bind -T copy-mode-vi y send-keys -X copy-selection-and-cancel set -g base-index 1 set -g pane-base-index 1 set -g status-interval 1 set -g status-justify left setw -g monitor-activity on # Set default term to xterm # https://github.com/zsh-users/zsh-autosuggestions/issues/229 # https://stackoverflow.com/questions/18600188/home-end-keys-do-not-work-in-tmux set -g default-terminal screen-256color Most useful shortcuts \u0026amp; cheetsheet  prefix means C-b by default, or C-a for me\nlist all shortcuts: prefix ?\n sessions  list session: tmux ls, prefix s new session: tmux new -s session_name (attach now), tmux new -d session_name (do not attach) attach session: tmux a -t session_name rename session: prefix $ kill session: tmux kill-session -t session_name  windows  new window: prefix c next window: prefix n previous window: prefix p rename window: prefix , kill window: prefix \u0026amp;  panes  change focus between panes: prefix h/j/k/l resize pane: prefix C-h/j/k/l split pane: prefix | vsplit pane: prefix - toggle zoom: prefix z kill pane: prefix x scroll pane: use mouse wheel or prefix [ then with vi motions  copy \u0026amp; paste  within tmux  select \u0026amp; copy with your mouse or first enter navigation: prefix [, then  navigate with vi motions: hjkl, C-f, C-b, \u0026hellip; v or shift+v to start character/line level selection o to change active end of selection y to yank (copy) or q to quit navigation prefix ] to paste selection     bettwen tmux and your host  hold shift and use mouse to select copy with Ctrl+Shift+c or Ctrl+c paste with Ctrl+Shift+v or Ctrl+v   ","description":"","id":2,"section":"posts","tags":["tmux","cheetsheet"],"title":"Tmux Basics","uri":"https://sky-bro.github.io/en/posts/tmux-basics/"},{"content":"setup hypervisor with qemu and kvm, the best linux based open source virtualization solution\nKVM is part of linux kernel, and QEMU (Quick EMUlator) is an emulator. KVM by itself cannot provide the complete virtualization solution, it needs QEMU to provide full hypervisor functionality. QEMU can emulate cpu on its own, but with KVM, QEMU can achieve near native performance by executing the guest code directly on the host CPU.\nSo it\u0026rsquo;s best for them to work together.\ntools you need Use your own package manager to install these tools:\n1 2 3 4 5 6 7 8 9  # I\u0026#39;m using arch, so... sudo pacman -Sy --needed \\  qemu \\  virt-viewer \\  libvirt \\  dnsmasq \\  ebtables \\  virt-install \\  virt-manager \\    kvm (Kernel-based Virtual Machine): Kernel module that handles CPU and memory communication qemu (Quick EMUlator): emulates many hardware resources \u0026ndash; dick, network, usb\u0026hellip; libvirt: an open-source API, daemon and management tool for managing platform virtualization. It can be used to manage KVM, Xen, VMware ESXi, QEMU and other virtualization technologies. virsh: Command-line tools for communicating with libvirt virt-manager: GUI alternative to virsh, albeit less capable. virt-viewer: part of virt-manager project, create new VM guests virt-install: part of virt-manager project, UI for interacting with VMs via VNC/SPICE dnsmasq: light-weight DNS/DHCP server. Primarily used for allocating IPs to VMs. ebtables: used for setting up NAT networking the host  some setup two problems\n by default, virt-manager talks to qemu:///system, and virsh talks to qemu:///session (unless run as sudo). when talking to qemu:///system, we need to input password every time, especially unpleasant experience when a cli tool like virsh.  For the first problem, we can tell virsh to use qemu:///system by default\n1 2  cp /etc/libvirt/libvirt.conf ~/.config/libvirt/libvirt.conf vim ~/.config/libvirt/libvirt.conf # uncomment or add: uri_default = \u0026#34;qemu:///system\u0026#34;   To solve the second problem, we can add a rule to polkit to allow our group (wheel \u0026ndash; administrator group) to use virt-manager or vish without being asked for password.\nedit /etc/polkit-1/rules.d/xxx.rules, your path may be different.\n/* Allow users in wheel group to manage the libvirt daemon without authentication */ polkit.addRule(function(action, subject) { if (action.id == \u0026quot;org.libvirt.unix.manage\u0026quot; \u0026amp;\u0026amp; subject.isInGroup(\u0026quot;wheel\u0026quot;)) { return polkit.Result.YES; } }); start services 1 2 3 4  systemctl enable libvirtd # start on boot systemctl start libvirtd # start libvirtd virsh net-autostart --network default virsh net-start --network default # start the default network   add shrarefolders in virtual machine manager, double click on one of your machine, then select view-\u0026gt;details-\u0026gt;Add Hardware, set something like below:\nThe above setting will add a new device /ctf in the virtual machine\nif in ubuntu sudo vim /etc/rc.local\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #!/bin/sh -e # # rc.local # # This script is executed at the end of each multiuser runlevel. # Make sure that the script will \u0026#34;exit 0\u0026#34; on success or any other # value on error. # # In order to enable or disable this script just change the execution # bits. # # By default this script does nothing. mount -t 9p -o trans=virtio,version=9p2000.L /ctf /home/sky/ctf exit 0   after restart this server, /ctf will automatically be mounted on /home/sky/ctf\nto make the user (actually kvm) writing the share folder same as the user at host (vm host):\nsudo vim /etc/libvirt/qemu.conf, find two lines with user=\u0026quot;xxx\u0026quot; and group=\u0026quot;xxx\u0026quot;, change them to yourself (by default, xxx should be root), then uncomment the two lines. for me, they are:\n1 2  user = \u0026#34;sky\u0026#34; group = \u0026#34;sky\u0026#34;   You may need to restart the libvirtd.service for this to take effect.\nAlso, you need to chown the disk to the above user:group: sudo chown sky:sky /var/lib/libvirt/images/ubt16-server.qcow2\ncreate a VM clone a VM useful virsh commands ref  Linux Hypervisor Setup (libvirt/qemu/kvm) Sharing folder with VM through libvirt, 9p, permission denied ","description":"","id":3,"section":"posts","tags":["hypervisor","kvm","qemu"],"title":"Linux Hypervisor Setup","uri":"https://sky-bro.github.io/en/posts/linux-hypervisor-setup/"},{"content":"Create new post First you need to create a file for you to write. Here\u0026rsquo;s how you can create a new post:\n1 2 3 4  hugo new posts/writing-guide.md # will create content/en/posts/writing-guide.md, \u0026#39;en\u0026#39; is set as my site\u0026#39;s default language hugo new posts/writing-guide.zh.md # content/zh/posts/writing-guide.zh.md hugo new posts/writing-guide/index.md # content/en/posts/writing-guide/index.md hugo new posts/writing-guide/index.zh.md # content/en/posts/writing-guide/index.zh.md   I prefer to create a directory for each of my writings, so I can add extra stuff like images for that specific page more easily.\nCode you can write multi-lines of code\n1 2 3 4 5 6 7 8 9 10  ````markdown # markdown code example keep nesting with different # of ticks (the more to the outside, the more ticks) ```markdown ## some header  * list item1 * list item2 ``` ````   Pictures 1 2  \u0026lt;!-- no caption by default --\u0026gt; ![an image in this directory](./images/scott.jpg)   1 2 3  \u0026lt;!-- better way, use figure shortcode --\u0026gt; \u0026lt;!-- to know more shortcodes: https://gohugo.io/content-management/shortcodes/ --\u0026gt; {{\u0026lt; figure src=\u0026#34;./images/scott.jpg\u0026#34; caption=\u0026#34;an image in this directory (this is Scott Adkins)\u0026#34; alt=\u0026#34;an image in this directory\u0026#34; \u0026gt;}}     an image in this directory (this is Scott Adkins)\n  Math Support (with MathJax) You can get some quick examples from: typora\u0026rsquo;s doc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  single \\\\$ for inline code: $x,y,z$ two \\\\$\u0026#39;s for block level code: $$z = \\sqrt{x^2 + y^2}$$ $$ \\begin{align*} y = y(x,t) \u0026amp;= A e^{i\\theta} \\\\\\\\ \u0026amp;= A (\\cos \\theta + i \\sin \\theta) \\\\\\\\ \u0026amp;= A (\\cos(kx - \\omega t) + i \\sin(kx - \\omega t)) \\\\\\\\ \u0026amp;= A\\cos(kx - \\omega t) + i A\\sin(kx - \\omega t) \\\\\\\\ \u0026amp;= A\\cos \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) + i A\\sin \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) \\\\\\\\ \u0026amp;= A\\cos \\frac{2\\pi}{\\lambda} (x - v t) + i A\\sin \\frac{2\\pi}{\\lambda} (x - v t) \\end{align*} $$   single \\$ for inline code: $x,y,z$\ntwo \\$\u0026rsquo;s for block level code:\n$$z = \\sqrt{x^2 + y^2}$$\n$$\n\\begin{align*}\ny = y(x,t) \u0026amp;= A e^{i\\theta} \\\\\n\u0026amp;= A (\\cos \\theta + i \\sin \\theta) \\\\\n\u0026amp;= A (\\cos(kx - \\omega t) + i \\sin(kx - \\omega t)) \\\\\n\u0026amp;= A\\cos(kx - \\omega t) + i A\\sin(kx - \\omega t) \\\\\n\u0026amp;= A\\cos \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) + i A\\sin \\Big(\\frac{2\\pi}{\\lambda}x - \\frac{2\\pi v}{\\lambda} t \\Big) \\\\\n\u0026amp;= A\\cos \\frac{2\\pi}{\\lambda} (x - v t) + i A\\sin \\frac{2\\pi}{\\lambda} (x - v t)\n\\end{align*}\n$$\nFlow charts TODO\nMore To be added\u0026hellip;\n","description":"Guides on how to wirte your contents using this theme (my cheetsheet).","id":4,"section":"posts","tags":[""],"title":"Writing Guide","uri":"https://sky-bro.github.io/en/posts/writing-guide/"},{"content":"Basic  password for user \u0026ldquo;bandit0\u0026rdquo; is \u0026ldquo;bandit0\u0026rdquo; ssh into the next host, e.g: ssh -p2220 bandit0@bandit.labs.overthewire.org find password for next level goto step 2  Tricks  hit \u0026lt;TAB\u0026gt; for command completion ls -a to show hidden files (names started with .) find command man command (man file)  Answers  level0 (password found: bandit0) level0-\u0026gt;level1: cat ./readme (password found: boJ9jbbUNNfktd78OOpsqOltutMc3MY1) level1-\u0026gt;level2: cat ./- (password found: CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9) level2-\u0026gt;level3: cat ./spaces\\ in\\ this\\ filename (password found: UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK) level3-\u0026gt;level4: ls -a ./inhere; cat ./inhere/.hidden (password found: pIwrPrtPN36QITSp3EQaw936yaFoFgAB) level4-\u0026gt;level5: file ./inhere/*; cat ./inhere/-file07 (password found: koReBOKuIDDepwhWk7jZC0RTdopnAYKh) level5-\u0026gt;level6: find ./ -size 1033c \\! -executable -readable; cat ./inhere/mabehere07/.file2 (password found: DXjZPULLxYr17uwoI01bNLQbtFemEgo7) level6-\u0026gt;level7: find / -size 33c -user bandit7 -group bandit6; cat /var/lib/dpkg/info/bandit7.password (password found: HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs) level7-\u0026gt;level8: grep millionth (password found: cvX2JJa4CFALtqS87jk27qwqGhBM9plV) level8-\u0026gt;level9: sort data.txt | uniq -u (password found: UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR) level9-\u0026gt;level10: strings data.txt | grep \u0026quot;===\u0026quot; (password found: truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk) level10-\u0026gt;level11: base64 -d data.txt (password found: IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR) level11-\u0026gt;level12: cat data.txt | tr \u0026quot;a-zA-Z\u0026quot; \u0026quot;n-za-mN-ZA-M\u0026quot; (password found: 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu) level12-\u0026gt;level13: xxd -r data.txt \u0026gt; data; file data; ... (password found: 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL) level13-\u0026gt;level14: ssh -i sshkey.private bandit14@localhost (password found: 4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e) level14-\u0026gt;level15: nc localhost 30000 (password found: BfMYroe26WYalil77FoDi9qh59eK5xNr) level15-\u0026gt;level16: nc localhost 30000 (password found: BfMYroe26WYalil77FoDi9qh59eK5xNr) https://overthewire.org/wargames/bandit/bandit16.html  ","description":"my solutions to the bandit wargame: https://overthewire.org/wargames/bandit/","id":5,"section":"posts","tags":["wargames"],"title":"Wargames Bandit","uri":"https://sky-bro.github.io/en/posts/wargames-bandit/"},{"content":"A de Bruijn sequence of order n on a size-k alphabet A is a cyclic sequence in which every possible length-n string on A occurs exactly once as a substring.\nFor a de Bruijn sequence of order n on a size-k alphabet $A$, we denote it by $B(k, n)$\nBasic Properties  $B(k, n)$ has length $k^n$ (also the number of distinct strings of length n on A) De Bruijn sequences are optimally short with respect to the property of containing every string of length n exactly once The number of distinct de Bruijn sequences $B(k, n)$ is\n$$\\frac{(k!)^{k^{n-1}}}{k^n}$$  An Example Sequence let\u0026rsquo;s use $B(2, 4)$ as an example\nSequence 0000111101100101 (cyclic sequcence) belongs to $B(2,4)$.\nIt contains every string of length n exactly once:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  {0 0 0 0} 1 1 1 1 0 1 1 0 0 1 0 1 0 {0 0 0 1} 1 1 1 0 1 1 0 0 1 0 1 0 0 {0 0 1 1} 1 1 0 1 1 0 0 1 0 1 0 0 0 {0 1 1 1} 1 0 1 1 0 0 1 0 1 0 0 0 0 {1 1 1 1} 0 1 1 0 0 1 0 1 0 0 0 0 1 {1 1 1 0} 1 1 0 0 1 0 1 0 0 0 0 1 1 {1 1 0 1} 1 0 0 1 0 1 0 0 0 0 1 1 1 {1 0 1 1} 0 0 1 0 1 0 0 0 0 1 1 1 1 {0 1 1 0} 0 1 0 1 0 0 0 0 1 1 1 1 0 {1 1 0 0} 1 0 1 0 0 0 0 1 1 1 1 0 1 {1 0 0 1} 0 1 0 0 0 0 1 1 1 1 0 1 1 {0 0 1 0} 1 0 0 0 0 1 1 1 1 0 1 1 0 {0 1 0 1} 0} 0 0 0 1 1 1 1 0 1 1 0 0 {1 0 1 ... ... 0 0} 0 0 1 1 1 1 0 1 1 0 0 1 {0 1 ... ... 0 0 0} 0 1 1 1 1 0 1 1 0 0 1 0 {1 ...   How to Construct the Sequence Can be constructed by taking an Eulerian cycle of an (n − 1)-dimensional de Bruijn graph: (Hierholzer’s Algorithm)\n  A de Bruijn graph\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  // copied from geeksforgeeks #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; unordered_set\u0026lt;string\u0026gt; seen; vector\u0026lt;int\u0026gt; edges; // Modified DFS in which no edge // is traversed twice void dfs(string node, int\u0026amp; k, string\u0026amp; A) { for (int i = 0; i \u0026lt; k; ++i) { string str = node + A[i]; if (seen.find(str) == seen.end()) { seen.insert(str); dfs(str.substr(1), k, A); edges.push_back(i); } } } // Function to find a de Bruijn sequence // of order n on k characters string deBruijn(int n, int k, string A) { // Clearing global variables  seen.clear(); edges.clear(); string startingNode = string(n - 1, A[0]); dfs(startingNode, k, A); string S; // Number of edges  int l = pow(k, n); for (int i = 0; i \u0026lt; l; ++i) S += A[edges[i]]; S += startingNode; return S; } // Driver code int main() { int n = 3, k = 2; string A = \u0026#34;01\u0026#34;; cout \u0026lt;\u0026lt; deBruijn(n, k, A); return 0; }   Related Problems   leetcode 753: Cracking the Safe\nexample solution from leetcode discuss\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { int n, k, v; vector\u0026lt;vector\u0026lt;bool\u0026gt; \u0026gt; visited; string sequence; public: string crackSafe(int n, int k) { if (k == 1) return string(n, \u0026#39;0\u0026#39;); this-\u0026gt;n = n; this-\u0026gt;k = k; v = 1; for (int i = 0; i \u0026lt; n - 1; ++i) v *= k; visited.resize(v, vector\u0026lt;bool\u0026gt;(k, false)); dfs(0); return sequence + sequence.substr(0, n - 1); } void dfs(int u) { for (int i = 0; i \u0026lt; k; ++i) { if (!visited[u][i]) { visited[u][i] = true; dfs((u * k + i) % v); sequence.push_back(\u0026#39;0\u0026#39; + i); } } } };     Refs  wiki: De Bruijn sequence geeksforgeeks: De Bruijn sequence | Set 1 ","description":"","id":6,"section":"posts","tags":["math","dfs"],"title":"De Bruijn Sequence","uri":"https://sky-bro.github.io/en/posts/de-bruijn-sequence/"},{"content":"Old way use rand(), usually pair with a random initialization of the seed:\n1 2  srand(int(time(0))); // initialize the seed rand(); // get a random int, [0, RAND_MAX]   get random int in [0,x): rand()%x\nget random real in [0, 1]: rand()/double(RAND_MAX)\nModern way 1 2 3 4 5  // ... #include \u0026lt;random\u0026gt; std::random_device rng; std::mt19937 urng(rng());   random_device random_device is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\nA good implementation should has its randomness come from a non-deterministic source (e.g. a hardware device).\nWe can just use this to get our random numbers, but it might come with a light performance price. A PRNG is much better\npseudo RNG So, we usually use random_device to get our first random number, then use it to initialize other PRNGs, then we can more quickly get many more random numbers.\nThe STL implements several PRNGs (see cppref: Predefined random number generators), not just the Mersenne Twister shown above, you can check\nUse cases of PRNG TODO\u0026hellip;\nRefs  cppref: std::random_device cppref: Predefined random number generators std::random_shuffle is deprecated in C++14  ","description":"introduce randomness into your C++ programs, the right way.","id":7,"section":"posts","tags":["RNG","C++","Random","STL"],"title":"Use Random in C++","uri":"https://sky-bro.github.io/en/posts/use-random-in-c++/"},{"content":"Yes, by default I heard before that using scanf/printf is faster than using cin/cout, and it\u0026rsquo;s true from my real experience, but I really didn\u0026rsquo;t get to know the reason behind, and later in leetcode, I saw others include these lines in their code:\n1 2 3  ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);   I\u0026rsquo;m almost certain that these lines are included to speed up their code. So out of curiosity, I did some searching, here\u0026rsquo;s what I\u0026rsquo;ve found:\nWhy cin \u0026amp; cout is slow First Reason: unbuffered streams By default, C++ streams are synchronized to the standard C streams after each input/output operation, meaning that C++ streams are unbuffered, each I/O operation on a C++ stream is immediately applied to the corresponding C stream\u0026rsquo;s buffer.\nSo this is the main reaseon: To be compatible with C (so you can mix your C code inside C++), C++ do not buffer its streams.\nSecond Reason: cin, cout streams are tied together By default, cin is tied to cout, and wcin to wcout, guarantees the flushing of cout before cin executes an input. In pure C, you may have to guarantee this by manually using fflush after the printf.\nWhat these three lines do ios::sync_with_stdio(false) As said above, by default c++ streams share c streams' buffers. This can be tweeked using the ios::sync_with_stdio(bool sync = true) function. After setting the sychronization to false, the synchronization between the C and C++ standard streams is disabled, C++ will use its own buffer.\ncin.tie(NULL) \u0026amp; cout.tie(NULL) tie is used to tie a stream (in/out) to some output stream, if the parameter is NULL, untie this stream from any tied stream (returns previous tied stream)\nif called without any argument, return the tied stream:\n1  *cin.tie() \u0026lt;\u0026lt; 123; // same as cout \u0026lt;\u0026lt; 123; (by default, cin is tied to cout)   so this is just used to untie cin/cout from any tied output stream (normally we just need to use cin.tie(0)), then the previously tied output stream won\u0026rsquo;t be forced to flush.\nWhen should I use the \u0026ldquo;speed up\u0026rdquo; Know the adventures   If you disable the synchronization, then C++ streams are allowed to have their own independent buffers, which makes mixing C- and C++-style I/O an adventure. Also, synchronized C++ streams are thread-safe (output from different threads may interleave, but you get no data races). (refer cppref)\n  If you untie cin, then later when you execute the lines below, you won\u0026rsquo;t be guaranteed to see the prompt before the input request from cin.\n  1 2 3  string name; cout \u0026lt;\u0026lt; \u0026#34;Please input your name:\u0026#34;; cin \u0026gt;\u0026gt; name;   Decide If you do not mix use the C- and C++-style I/O, do not write multi-thread program, use ios::sync_with_stdio(false).\nIf you do not care about seeing some output before your input, use tie(0).\nExample 1 2 3 4 5  int main() { // ... } static int x = []() {ios::sync_with_stdio(false); cin.tie(0); return 0; } ();   Refs  cppref: std::ios_base::sync_with_stdio cppref: std::basic_ios\u0026lt;CharT,Traits\u0026gt;::tie Why do we need to tie std::cin and std::cout?  ","description":"is or why is cin, cout slow in C++?","id":8,"section":"posts","tags":["C++"],"title":"cin \u0026 cout is slow?","uri":"https://sky-bro.github.io/en/posts/cin-cout-is-slow/"},{"content":"A segment tree is a binary tree where each node represents an interval. Each node stores some property of its corresponding interval: like the maximum/minimum num, the sum of that interval.\nApplicable Problems For any array a, where every element belongs to some monoid $(S, \\oplus)$ we can build a segment tree to answer the following queries (problems):\n– Get(l, r) — returns $a_l \\oplus a_{l+1} \\oplus \\dotsb a_r$\n– Change(p, x) — set $a_p = x$\n Monoids are semigroups with identity. $\\oplus$ is an associative binary operation. Identity element for some pair $(S, \\oplus)$ is such an element $e \\in S$ that for every $a \\in S$ condition $a ⊕ e = e \\oplus a = a$ holds;   Example Problem leetcode 307: Range Sum Query - Mutable\nGiven an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.\nThe update(i, val) function modifies nums by updating the element at index i to val. For this problem, the identity element is 0, and the binary operation is + between integers.\nAnd for simplicity we use the identity element to extend the length of the original array to some integer power of 2.\n  Padded Segment Tree\n  if size of the array is n, then we only need an array of 2*n length to store the segment tree. (only in iterative version, property of a Complete Binary Tree)\n  Segment Tree Built Iteratively\n  Define the binary operation Here we will just use + for our operation, you can if you need define a merge function for your special operation $\\oplus$.\n1 2 3  inline int merge(int a, int b) { return a + b; }   Build the Tree We want to construct an array like above (the original array is {1, 2, 3, 4, 5, 6}), the essential idea of a segment tree is that a node at index $i$ (index starts from 1, you can also try starting from 0, but starting from 1 is simpler) can have two children at indexes $(2 \\ast i)$ and $(2 \\ast i + 1)$.\n1 2 3 4 5 6 7 8 9 10  NumArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { n = nums.size(); segment_tree.resize(2 * n); for (int i = 0; i \u0026lt; n; ++i) { segment_tree[i + n] = nums[i]; } for (int i = n - 1; i \u0026gt; 0; --i) { segment_tree[i] = segment_tree[i\u0026lt;\u0026lt;1] + segment_tree[i\u0026lt;\u0026lt;1|1]; } }   Query a range sum 1 2 3 4 5 6 7 8  int sumRange(int i, int j) { // sum range [i, j]  int sum = 0; for (i += n, j += n+1; i \u0026lt; j; i \u0026gt;\u0026gt;= 1, j \u0026gt;\u0026gt;= 1) { if (i\u0026amp;1) sum += segment_tree[i++]; if (j\u0026amp;1) sum += segment_tree[--j]; } return sum; }   Update an element/elements 1 2 3 4 5 6 7  void update(int i, int val) { i += n; if (segment_tree[i] == val) return; for (segment_tree[i] = val; i \u0026gt; 1; i \u0026gt;\u0026gt;= 1) { segment_tree[i\u0026gt;\u0026gt;1] = segment_tree[i] + segment_tree[i^1]; } }   Complete Solution to the Problem   Leetcode 307 Solution (C\u0026#43;\u0026#43;)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class NumArray { private: int n; vector\u0026lt;int\u0026gt; segment_tree; public: NumArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { n = nums.size(); segment_tree.resize(2*n); for (int i = 0; i \u0026lt; n; ++i) { segment_tree[i+n] = nums[i]; } for (int i = n-1; i \u0026gt; 0; --i) { segment_tree[i] = segment_tree[i\u0026lt;\u0026lt;1] + segment_tree[i\u0026lt;\u0026lt;1|1]; } } void update(int i, int val) { i += n; if (segment_tree[i] == val) return; for (segment_tree[i] = val; i \u0026gt; 1; i \u0026gt;\u0026gt;= 1) { segment_tree[i\u0026gt;\u0026gt;1] = segment_tree[i] + segment_tree[i^1]; } } int sumRange(int i, int j) { // sum range [i, j]  int sum = 0; for (i += n, j += n+1; i \u0026lt; j; i \u0026gt;\u0026gt;= 1, j \u0026gt;\u0026gt;= 1) { if (i\u0026amp;1) sum += segment_tree[i++]; if (j\u0026amp;1) sum += segment_tree[--j]; } return sum; } };      Refs  youtube: Efficient Segment Tree Tutorial codeforces: Efficient and easy segment trees: best Segment tree Theory and applications wiki: binary tree - in an array ","description":"","id":9,"section":"posts","tags":["segment tree"],"title":"Segment Tree (Iterative)","uri":"https://sky-bro.github.io/en/posts/segment-tree-iterative/"},{"content":"let\u0026rsquo;s learn how to use heap in C++\nRelated functions    func description     make_heap Make heap from range   push_heap Push element into heap range   pop_heap Pop element from heap range   sort_heap Sort elements of heap   is_heap Test if range is heap   is_heap_until Find first element not in heap order    make_heap  make heap from range\n We need to have a heap before we operate on a heap, make_heap let\u0026rsquo;s us rearrange elements in a range.\nUsually we use a vector to hold these range of elements:\n1 2 3 4 5 6  #include \u0026lt;iostream\u0026gt; // std::cout#include \u0026lt;algorithm\u0026gt; // std::make_heap, std::pop_heap, std::push_heap, std::sort_heap#include \u0026lt;vector\u0026gt; // std::vector std::vector\u0026lt;int\u0026gt; heap{1,2,3,4,5,6,7}; std::make_heap(heap.begin(), heap.end()); // 7 5 6 4 2 1 3   For now, you only need to know that after make_heap, the biggest element is *begin(heap) or heap[0]. Other elements are not necessarily sorted, but arranged in a certain way, to know the detail, see heap in C++ 2.\npush_heap  Push element into heap range\n Given a heap in the range [first,last-1), this function extends the range considered a heap to [first,last) by placing the value in (last-1) into its corresponding location within it.\nMeaning to add an element to a heap:\n1 2  heap.push_back(8); // 7 5 6 4 2 1 3 8 std::push_heap(heap.begin(), heap.end()); // 8 7 6 5 2 1 3 4   push_heap will adjust the elements in the new range (old range + 1), and place the added element to where it fits.\npop_heap  Pop element from heap range\n Given a heap in the range [first,last), this function rearranges the elements in the heap range [first,last) in such a way that the part considered a heap is shortened by one: The element with the highest value is moved to (last-1).\nMeaning to pop out the largest element from the heap:\n1  std::pop_heap(heap.begin(), heap.end()); // 7 5 6 4 2 1 3 8   new heap range: [first, last-1)\nis_heap  Test if range is heap\n simple as description, code:\n1 2 3  // heap: 7 5 6 4 2 1 3 8 std::is_heap(heap.begin(), heap.end()); // false std::is_heap(heap.begin(), heap.end()-1); // true   is_heap_until  Find first element not in heap order\n We\u0026rsquo;ve already popped out 8 from the heap, so:\n1 2 3  // 7 5 6 4 2 1 3 8 auto it = std::is_heap_until(heap.begin(), heap.end()); std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; // 8   sort_heap  Sort elements of heap\n Sorts the elements in the heap range [first,last) into ascending order.\nThis is actually quite simple, you may have as well implement this function yourself, just keep doing pop_heap until the heap is shortened to 1.\n1  std::sort_heap(heap.begin(), heap.end() - 1, cmp); // 1 2 3 4 5 6 7 8   Code Examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  #include \u0026lt;algorithm\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;random\u0026gt;#include \u0026lt;vector\u0026gt; template \u0026lt;typename T\u0026gt; void printArr(const std::vector\u0026lt;T\u0026gt; \u0026amp;arr) { for (const T \u0026amp;t : arr) std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34; \u0026#34;; std::cout \u0026lt;\u0026lt; std::endl; } // std::random_device rd; // std::mt19937_64 urng(rd());  int main(int argc, char const *argv[]) { std::cout \u0026lt;\u0026lt; \u0026#34;original array\u0026#34; \u0026lt;\u0026lt; std::endl; std::vector\u0026lt;int\u0026gt; heap(7); std::iota(heap.begin(), heap.end(), 1); printArr(heap); // 1 2 3 4 5 6 7  // std::cout \u0026lt;\u0026lt; \u0026#34;shuffle\u0026#34; \u0026lt;\u0026lt; std::endl;  // std::shuffle(heap.begin(), heap.end(), urng);  // printArr(heap);  // auto cmp = std::greater\u0026lt;int\u0026gt;();  // auto cmp = std::less\u0026lt;int\u0026gt;();  std::cout \u0026lt;\u0026lt; \u0026#34;make heap\u0026#34; \u0026lt;\u0026lt; std::endl; std::make_heap(heap.begin(), heap.end()); printArr(heap); // 7 5 6 4 2 1 3  std::cout \u0026lt;\u0026lt; \u0026#34;push back 8\u0026#34; \u0026lt;\u0026lt; std::endl; heap.push_back(8); printArr(heap); // 7 5 6 4 2 1 3 8  std::cout \u0026lt;\u0026lt; \u0026#34;push heap\u0026#34; \u0026lt;\u0026lt; std::endl; std::push_heap(heap.begin(), heap.end()); printArr(heap); // 8 7 6 5 2 1 3 4  std::cout \u0026lt;\u0026lt; \u0026#34;pop heap\u0026#34; \u0026lt;\u0026lt; std::endl; std::pop_heap(heap.begin(), heap.end()); printArr(heap); // 7 5 6 4 2 1 3 8  std::cout \u0026lt;\u0026lt; \u0026#34;is heap\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::is_heap(heap.begin(), heap.end()) \u0026lt;\u0026lt; std::endl; // 0  std::cout \u0026lt;\u0026lt; \u0026#34;is heap until\u0026#34; \u0026lt;\u0026lt; std::endl; auto it = std::is_heap_until(heap.begin(), heap.end()); std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; // 8  std::cout \u0026lt;\u0026lt; \u0026#34;sort heap (begin, end-1)\u0026#34; \u0026lt;\u0026lt; std::endl; std::sort_heap(heap.begin(), heap.end() - 1); printArr(heap); // 1 2 3 4 5 6 7 8  return 0; }   Refs  cplusplus.com: see heap algorithms  ","description":"learn how to use heap in C++","id":10,"section":"posts","tags":["C++","heap"],"title":"Heap in C++","uri":"https://sky-bro.github.io/en/posts/heap-in-c++/"},{"content":"🚩 This Site Generated using Hugo，source code here: blog-src, and the theme is forked (my fork) from: hugo-theme-zzo\n🌅 Daily Life  @HIT C / C++, Python, ASM Arch, VSCode CTF / Binary  💌 Contact Me  Email: sky_io@outlook.com WeChat: sky_bro Facebook: Kaiyu Shi Twitter: KaiyuShi GPG Pub: Kyle.asc (F4CD 0E4A 3661 65D1 62E6 B6CE 7D36 AE60 55B0 60A6)  🐔 My Friends TheSong, 路人枭, wxk\n🎼 Listening recently \n","description":"About Kyle Shi / sky / Kaiyu Shi, whoami, I am an enthusiast!","id":11,"section":"","tags":null,"title":"About","uri":"https://sky-bro.github.io/en/about/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":12,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://sky-bro.github.io/en/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":13,"section":"gallery","tags":null,"title":"Photo","uri":"https://sky-bro.github.io/en/gallery/photo/"}]