[{"content":"Basic  password for user \u0026ldquo;bandit0\u0026rdquo; is \u0026ldquo;bandit0\u0026rdquo; ssh into the next host, e.g: ssh -p2220 bandit0@bandit.labs.overthewire.org find password for next level goto step 2  Tricks  hit \u0026lt;TAB\u0026gt; for command completion ls -a to show hidden files (names started with .) find command man command (man file)  Answers  level0 (password found: bandit0) level0-\u0026gt;level1: cat ./readme (password found: boJ9jbbUNNfktd78OOpsqOltutMc3MY1) level1-\u0026gt;level2: cat ./- (password found: CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9) level2-\u0026gt;level3: cat ./spaces\\ in\\ this\\ filename (password found: UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK) level3-\u0026gt;level4: ls -a ./inhere; cat ./inhere/.hidden (password found: pIwrPrtPN36QITSp3EQaw936yaFoFgAB) level4-\u0026gt;level5: file ./inhere/*; cat ./inhere/-file07 (password found: koReBOKuIDDepwhWk7jZC0RTdopnAYKh) level5-\u0026gt;level6: find ./ -size 1033c \\! -executable -readable; cat ./inhere/mabehere07/.file2 (password found: DXjZPULLxYr17uwoI01bNLQbtFemEgo7) level6-\u0026gt;level7: find / -size 33c -user bandit7 -group bandit6; cat /var/lib/dpkg/info/bandit7.password (password found: HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs) level7-\u0026gt;level8: grep millionth (password found: cvX2JJa4CFALtqS87jk27qwqGhBM9plV) level8-\u0026gt;level9: sort data.txt | uniq -u (password found: UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR) level9-\u0026gt;level10: strings data.txt | grep \u0026quot;===\u0026quot; (password found: truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk) level10-\u0026gt;level11: base64 -d data.txt (password found: IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR) level11-\u0026gt;level12: cat data.txt | tr \u0026quot;a-zA-Z\u0026quot; \u0026quot;n-za-mN-ZA-M\u0026quot; (password found: 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu) level12-\u0026gt;level13: xxd -r data.txt \u0026gt; data; file data; ... (password found: 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL) level13-\u0026gt;level14: ssh -i sshkey.private bandit14@localhost (password found: 4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e) level14-\u0026gt;level15: nc localhost 30000 (password found: BfMYroe26WYalil77FoDi9qh59eK5xNr) level15-\u0026gt;level16: nc localhost 30000 (password found: BfMYroe26WYalil77FoDi9qh59eK5xNr) https://overthewire.org/wargames/bandit/bandit16.html  ","description":"my solutions to the bandit wargame: https://overthewire.org/wargames/bandit/","id":2,"section":"posts","tags":["wargames"],"title":"Wargames Bandit","uri":"https://sky-bro.github.io/en/posts/wargames-bandit/"},{"content":"A de Bruijn sequence of order n on a size-k alphabet A is a cyclic sequence in which every possible length-n string on A occurs exactly once as a substring.\nFor a de Bruijn sequence of order n on a size-k alphabet $A$, we denote it by $B(k, n)$\nBasic Properties  $B(k, n)$ has length $k^n$ (also the number of distinct strings of length n on A) De Bruijn sequences are optimally short with respect to the property of containing every string of length n exactly once The number of distinct de Bruijn sequences $B(k, n)$ is\n$$\\frac{(k!)^{k^{n-1}}}{k^n}$$  An Example Sequence let\u0026rsquo;s use $B(2, 4)$ as an example\nSequence 0000111101100101 (cyclic sequcence) belongs to $B(2,4)$.\nIt contains every string of length n exactly once:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  {0 0 0 0} 1 1 1 1 0 1 1 0 0 1 0 1 0 {0 0 0 1} 1 1 1 0 1 1 0 0 1 0 1 0 0 {0 0 1 1} 1 1 0 1 1 0 0 1 0 1 0 0 0 {0 1 1 1} 1 0 1 1 0 0 1 0 1 0 0 0 0 {1 1 1 1} 0 1 1 0 0 1 0 1 0 0 0 0 1 {1 1 1 0} 1 1 0 0 1 0 1 0 0 0 0 1 1 {1 1 0 1} 1 0 0 1 0 1 0 0 0 0 1 1 1 {1 0 1 1} 0 0 1 0 1 0 0 0 0 1 1 1 1 {0 1 1 0} 0 1 0 1 0 0 0 0 1 1 1 1 0 {1 1 0 0} 1 0 1 0 0 0 0 1 1 1 1 0 1 {1 0 0 1} 0 1 0 0 0 0 1 1 1 1 0 1 1 {0 0 1 0} 1 0 0 0 0 1 1 1 1 0 1 1 0 {0 1 0 1} 0} 0 0 0 1 1 1 1 0 1 1 0 0 {1 0 1 ... ... 0 0} 0 0 1 1 1 1 0 1 1 0 0 1 {0 1 ... ... 0 0 0} 0 1 1 1 1 0 1 1 0 0 1 0 {1 ...   How to Construct the Sequence Can be constructed by taking an Eulerian cycle of an (n ‚àí 1)-dimensional de Bruijn graph: (Hierholzer‚Äôs Algorithm)\n  A de Bruijn graph\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  // copied from geeksforgeeks #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; unordered_set\u0026lt;string\u0026gt; seen; vector\u0026lt;int\u0026gt; edges; // Modified DFS in which no edge // is traversed twice void dfs(string node, int\u0026amp; k, string\u0026amp; A) { for (int i = 0; i \u0026lt; k; ++i) { string str = node + A[i]; if (seen.find(str) == seen.end()) { seen.insert(str); dfs(str.substr(1), k, A); edges.push_back(i); } } } // Function to find a de Bruijn sequence // of order n on k characters string deBruijn(int n, int k, string A) { // Clearing global variables  seen.clear(); edges.clear(); string startingNode = string(n - 1, A[0]); dfs(startingNode, k, A); string S; // Number of edges  int l = pow(k, n); for (int i = 0; i \u0026lt; l; ++i) S += A[edges[i]]; S += startingNode; return S; } // Driver code int main() { int n = 3, k = 2; string A = \u0026#34;01\u0026#34;; cout \u0026lt;\u0026lt; deBruijn(n, k, A); return 0; }   Related Problems   leetcode 753: Cracking the Safe\nexample solution from leetcode discuss\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { int n, k, v; vector\u0026lt;vector\u0026lt;bool\u0026gt; \u0026gt; visited; string sequence; public: string crackSafe(int n, int k) { if (k == 1) return string(n, \u0026#39;0\u0026#39;); this-\u0026gt;n = n; this-\u0026gt;k = k; v = 1; for (int i = 0; i \u0026lt; n - 1; ++i) v *= k; visited.resize(v, vector\u0026lt;bool\u0026gt;(k, false)); dfs(0); return sequence + sequence.substr(0, n - 1); } void dfs(int u) { for (int i = 0; i \u0026lt; k; ++i) { if (!visited[u][i]) { visited[u][i] = true; dfs((u * k + i) % v); sequence.push_back(\u0026#39;0\u0026#39; + i); } } } };     Refs  wiki: De Bruijn sequence geeksforgeeks: De Bruijn sequence | Set 1 ","description":"","id":3,"section":"posts","tags":["math","dfs"],"title":"De Bruijn Sequence","uri":"https://sky-bro.github.io/en/posts/de-bruijn-sequence/"},{"content":"Old way use rand(), usually pair with a random initialization of the seed:\n1 2  srand(int(time(0))); // initialize the seed rand(); // get a random int, [0, RAND_MAX]   get random int in [0,x): rand()%x\nget random real in [0, 1]: rand()/double(RAND_MAX)\nModern way 1 2 3 4 5  // ... #include \u0026lt;random\u0026gt; std::random_device rng; std::mt19937 urng(rng());   random_device random_device is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\nA good implementation should has its randomness come from a non-deterministic source (e.g. a hardware device).\nWe can just use this to get our random numbers, but it might come with a light performance price. A PRNG is much better\npseudo RNG So, we usually use random_device to get our first random number, then use it to initialize other PRNGs, then we can more quickly get many more random numbers.\nThe STL implements several PRNGs (see cppref: Predefined random number generators), not just the Mersenne Twister shown above, you can check\nUse cases of PRNG TODO\u0026hellip;\nRefs  cppref: std::random_device cppref: Predefined random number generators std::random_shuffle is deprecated in C++14  ","description":"introduce randomness into your C++ programs, the right way.","id":4,"section":"posts","tags":["RNG","C++","Random","STL"],"title":"Use Random in C++","uri":"https://sky-bro.github.io/en/posts/use-random-in-c++/"},{"content":"Yes, by default I heard before that using scanf/printf is faster than using cin/cout, and it\u0026rsquo;s true from my real experience, but I really didn\u0026rsquo;t get to know the reason behind, and later in leetcode, I saw others include these lines in their code:\n1 2 3  ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);   I\u0026rsquo;m almost certain that these lines are included to speed up their code. So out of curiosity, I did some searching, here\u0026rsquo;s what I\u0026rsquo;ve found:\nWhy cin \u0026amp; cout is slow First Reason: unbuffered streams By default, C++ streams are synchronized to the standard C streams after each input/output operation, meaning that C++ streams are unbuffered, each I/O operation on a C++ stream is immediately applied to the corresponding C stream\u0026rsquo;s buffer.\nSo this is the main reaseon: To be compatible with C (so you can mix your C code inside C++), C++ do not buffer its streams.\nSecond Reason: cin, cout streams are tied together By default, cin is tied to cout, and wcin to wcout, guarantees the flushing of cout before cin executes an input. In pure C, you may have to guarantee this by manually using fflush after the printf.\nWhat these three lines do ios::sync_with_stdio(false) As said above, by default c++ streams share c streams' buffers. This can be tweeked using the ios::sync_with_stdio(bool sync = true) function. After setting the sychronization to false, the synchronization between the C and C++ standard streams is disabled, C++ will use its own buffer.\ncin.tie(NULL) \u0026amp; cout.tie(NULL) tie is used to tie a stream (in/out) to some output stream, if the parameter is NULL, untie this stream from any tied stream (returns previous tied stream)\nif called without any argument, return the tied stream:\n1  *cin.tie() \u0026lt;\u0026lt; 123; // same as cout \u0026lt;\u0026lt; 123; (by default, cin is tied to cout)   so this is just used to untie cin/cout from any tied output stream (normally we just need to use cin.tie(0)), then the previously tied output stream won\u0026rsquo;t be forced to flush.\nWhen should I use the \u0026ldquo;speed up\u0026rdquo; Know the adventures   If you disable the synchronization, then C++ streams are allowed to have their own independent buffers, which makes mixing C- and C++-style I/O an adventure. Also, synchronized C++ streams are thread-safe (output from different threads may interleave, but you get no data races). (refer cppref)\n  If you untie cin, then later when you execute the lines below, you won\u0026rsquo;t be guaranteed to see the prompt before the input request from cin.\n  1 2 3  string name; cout \u0026lt;\u0026lt; \u0026#34;Please input your name:\u0026#34;; cin \u0026gt;\u0026gt; name;   Decide If you do not mix use the C- and C++-style I/O, do not write multi-thread program, use ios::sync_with_stdio(false).\nIf you do not care about seeing some output before your input, use tie(0).\nExample 1 2 3 4 5  int main() { // ... } static int x = []() {ios::sync_with_stdio(false); cin.tie(0); return 0; } ();   Refs  cppref: std::ios_base::sync_with_stdio cppref: std::basic_ios\u0026lt;CharT,Traits\u0026gt;::tie Why do we need to tie std::cin and std::cout?  ","description":"is or why is cin, cout slow in C++?","id":5,"section":"posts","tags":["C++"],"title":"cin \u0026 cout is slow?","uri":"https://sky-bro.github.io/en/posts/cin-cout-is-slow/"},{"content":"A segment tree is a binary tree where each node represents an interval. Each node stores some property of its corresponding interval: like the maximum/minimum num, the sum of that interval.\nApplicable Problems For any array a, where every element belongs to some monoid $(S, \\oplus)$ we can build a segment tree to answer the following queries (problems):\n‚Äì Get(l, r) ‚Äî returns $a_l \\oplus a_{l+1} \\oplus \\dotsb a_r$\n‚Äì Change(p, x) ‚Äî set $a_p = x$\n Monoids are semigroups with identity. $\\oplus$ is an associative binary operation. Identity element for some pair $(S, \\oplus)$ is such an element $e \\in S$ that for every $a \\in S$ condition $a ‚äï e = e \\oplus a = a$ holds;   Example Problem leetcode 307: Range Sum Query - Mutable\nGiven an integer array nums, find the sum of the elements between indices i and j (i ‚â§ j), inclusive.\nThe update(i, val) function modifies nums by updating the element at index i to val. For this problem, the identity element is 0, and the binary operation is + between integers.\nAnd for simplicity we use the identity element to extend the length of the original array to some integer power of 2.\n  Padded Segment Tree\n  if size of the array is n, then we only need an array of 2*n length to store the segment tree. (only in iterative version, property of a Complete Binary Tree)\n  Segment Tree Built Iteratively\n  Define the binary operation Here we will just use + for our operation, you can if you need define a merge function for your special operation $\\oplus$.\n1 2 3  inline int merge(int a, int b) { return a + b; }   Build the Tree We want to construct an array like above (the original array is {1, 2, 3, 4, 5, 6}), the essential idea of a segment tree is that a node at index $i$ (index starts from 1, you can also try starting from 0, but starting from 1 is simpler) can have two children at indexes $(2 \\ast i)$ and $(2 \\ast i + 1)$.\n1 2 3 4 5 6 7 8 9 10  NumArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { n = nums.size(); segment_tree.resize(2 * n); for (int i = 0; i \u0026lt; n; ++i) { segment_tree[i + n] = nums[i]; } for (int i = n - 1; i \u0026gt; 0; --i) { segment_tree[i] = segment_tree[i\u0026lt;\u0026lt;1] + segment_tree[i\u0026lt;\u0026lt;1|1]; } }   Query a range sum 1 2 3 4 5 6 7 8  int sumRange(int i, int j) { // sum range [i, j]  int sum = 0; for (i += n, j += n+1; i \u0026lt; j; i \u0026gt;\u0026gt;= 1, j \u0026gt;\u0026gt;= 1) { if (i\u0026amp;1) sum += segment_tree[i++]; if (j\u0026amp;1) sum += segment_tree[--j]; } return sum; }   Update an element/elements 1 2 3 4 5 6 7  void update(int i, int val) { i += n; if (segment_tree[i] == val) return; for (segment_tree[i] = val; i \u0026gt; 1; i \u0026gt;\u0026gt;= 1) { segment_tree[i\u0026gt;\u0026gt;1] = segment_tree[i] + segment_tree[i^1]; } }   Complete Solution to the Problem   Leetcode 307 Solution (C\u0026#43;\u0026#43;)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class NumArray { private: int n; vector\u0026lt;int\u0026gt; segment_tree; public: NumArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { n = nums.size(); segment_tree.resize(2*n); for (int i = 0; i \u0026lt; n; ++i) { segment_tree[i+n] = nums[i]; } for (int i = n-1; i \u0026gt; 0; --i) { segment_tree[i] = segment_tree[i\u0026lt;\u0026lt;1] + segment_tree[i\u0026lt;\u0026lt;1|1]; } } void update(int i, int val) { i += n; if (segment_tree[i] == val) return; for (segment_tree[i] = val; i \u0026gt; 1; i \u0026gt;\u0026gt;= 1) { segment_tree[i\u0026gt;\u0026gt;1] = segment_tree[i] + segment_tree[i^1]; } } int sumRange(int i, int j) { // sum range [i, j]  int sum = 0; for (i += n, j += n+1; i \u0026lt; j; i \u0026gt;\u0026gt;= 1, j \u0026gt;\u0026gt;= 1) { if (i\u0026amp;1) sum += segment_tree[i++]; if (j\u0026amp;1) sum += segment_tree[--j]; } return sum; } };      Refs  youtube: Efficient Segment Tree Tutorial codeforces: Efficient and easy segment trees: best Segment tree Theory and applications wiki: binary tree - in an array ","description":"","id":6,"section":"posts","tags":["segment tree"],"title":"Segment Tree (Iterative)","uri":"https://sky-bro.github.io/en/posts/segment-tree-iterative/"},{"content":"let\u0026rsquo;s learn how to use heap in C++\nRelated functions    func description     make_heap Make heap from range   push_heap Push element into heap range   pop_heap Pop element from heap range   sort_heap Sort elements of heap   is_heap Test if range is heap   is_heap_until Find first element not in heap order    make_heap  make heap from range\n We need to have a heap before we operate on a heap, make_heap let\u0026rsquo;s us rearrange elements in a range.\nUsually we use a vector to hold these range of elements:\n1 2 3 4 5 6  #include \u0026lt;iostream\u0026gt; // std::cout#include \u0026lt;algorithm\u0026gt; // std::make_heap, std::pop_heap, std::push_heap, std::sort_heap#include \u0026lt;vector\u0026gt; // std::vector std::vector\u0026lt;int\u0026gt; heap{1,2,3,4,5,6,7}; std::make_heap(heap.begin(), heap.end()); // 7 5 6 4 2 1 3   For now, you only need to know that after make_heap, the biggest element is *begin(heap) or heap[0]. Other elements are not necessarily sorted, but arranged in a certain way, to know the detail, see heap in C++ 2.\npush_heap  Push element into heap range\n Given a heap in the range [first,last-1), this function extends the range considered a heap to [first,last) by placing the value in (last-1) into its corresponding location within it.\nMeaning to add an element to a heap:\n1 2  heap.push_back(8); // 7 5 6 4 2 1 3 8 std::push_heap(heap.begin(), heap.end()); // 8 7 6 5 2 1 3 4   push_heap will adjust the elements in the new range (old range + 1), and place the added element to where it fits.\npop_heap  Pop element from heap range\n Given a heap in the range [first,last), this function rearranges the elements in the heap range [first,last) in such a way that the part considered a heap is shortened by one: The element with the highest value is moved to (last-1).\nMeaning to pop out the largest element from the heap:\n1  std::pop_heap(heap.begin(), heap.end()); // 7 5 6 4 2 1 3 8   new heap range: [first, last-1)\nis_heap  Test if range is heap\n simple as description, code:\n1 2 3  // heap: 7 5 6 4 2 1 3 8 std::is_heap(heap.begin(), heap.end()); // false std::is_heap(heap.begin(), heap.end()-1); // true   is_heap_until  Find first element not in heap order\n We\u0026rsquo;ve already popped out 8 from the heap, so:\n1 2 3  // 7 5 6 4 2 1 3 8 auto it = std::is_heap_until(heap.begin(), heap.end()); std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; // 8   sort_heap  Sort elements of heap\n Sorts the elements in the heap range [first,last) into ascending order.\nThis is actually quite simple, you may have as well implement this function yourself, just keep doing pop_heap until the heap is shortened to 1.\n1  std::sort_heap(heap.begin(), heap.end() - 1, cmp); // 1 2 3 4 5 6 7 8   Code Examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  #include \u0026lt;algorithm\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;random\u0026gt;#include \u0026lt;vector\u0026gt; template \u0026lt;typename T\u0026gt; void printArr(const std::vector\u0026lt;T\u0026gt; \u0026amp;arr) { for (const T \u0026amp;t : arr) std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34; \u0026#34;; std::cout \u0026lt;\u0026lt; std::endl; } // std::random_device rd; // std::mt19937_64 urng(rd());  int main(int argc, char const *argv[]) { std::cout \u0026lt;\u0026lt; \u0026#34;original array\u0026#34; \u0026lt;\u0026lt; std::endl; std::vector\u0026lt;int\u0026gt; heap(7); std::iota(heap.begin(), heap.end(), 1); printArr(heap); // 1 2 3 4 5 6 7  // std::cout \u0026lt;\u0026lt; \u0026#34;shuffle\u0026#34; \u0026lt;\u0026lt; std::endl;  // std::shuffle(heap.begin(), heap.end(), urng);  // printArr(heap);  // auto cmp = std::greater\u0026lt;int\u0026gt;();  // auto cmp = std::less\u0026lt;int\u0026gt;();  std::cout \u0026lt;\u0026lt; \u0026#34;make heap\u0026#34; \u0026lt;\u0026lt; std::endl; std::make_heap(heap.begin(), heap.end()); printArr(heap); // 7 5 6 4 2 1 3  std::cout \u0026lt;\u0026lt; \u0026#34;push back 8\u0026#34; \u0026lt;\u0026lt; std::endl; heap.push_back(8); printArr(heap); // 7 5 6 4 2 1 3 8  std::cout \u0026lt;\u0026lt; \u0026#34;push heap\u0026#34; \u0026lt;\u0026lt; std::endl; std::push_heap(heap.begin(), heap.end()); printArr(heap); // 8 7 6 5 2 1 3 4  std::cout \u0026lt;\u0026lt; \u0026#34;pop heap\u0026#34; \u0026lt;\u0026lt; std::endl; std::pop_heap(heap.begin(), heap.end()); printArr(heap); // 7 5 6 4 2 1 3 8  std::cout \u0026lt;\u0026lt; \u0026#34;is heap\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::is_heap(heap.begin(), heap.end()) \u0026lt;\u0026lt; std::endl; // 0  std::cout \u0026lt;\u0026lt; \u0026#34;is heap until\u0026#34; \u0026lt;\u0026lt; std::endl; auto it = std::is_heap_until(heap.begin(), heap.end()); std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; // 8  std::cout \u0026lt;\u0026lt; \u0026#34;sort heap (begin, end-1)\u0026#34; \u0026lt;\u0026lt; std::endl; std::sort_heap(heap.begin(), heap.end() - 1); printArr(heap); // 1 2 3 4 5 6 7 8  return 0; }   Refs  cplusplus.com: see heap algorithms  ","description":"learn how to use heap in C++","id":7,"section":"posts","tags":["C++","heap"],"title":"Heap in C++","uri":"https://sky-bro.github.io/en/posts/heap-in-c++/"},{"content":"üö© This Site Generated using HugoÔºåsource code here: blog-src, and the theme is forked (my fork) from: hugo-theme-zzo\nüåÖ Daily Life  @HIT C / C++, Python, ASM Arch, VSCode CTF / Binary  üíå Contact Me  Email: sky_io@outlook.com WeChat: sky_bro Facebook: Kaiyu Shi Twitter: KaiyuShi GPG Pub: Kyle.asc (F4CD 0E4A 3661 65D1 62E6 B6CE 7D36 AE60 55B0 60A6)  üêî My Friends TheSong, Ë∑Ø‰∫∫Êû≠\nüéº Listening \n","description":"About Kyle Shi / sky / Kaiyu Shi, whoami, I am an enthusiast!","id":8,"section":"","tags":null,"title":"About","uri":"https://sky-bro.github.io/en/about/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":9,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://sky-bro.github.io/en/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":10,"section":"gallery","tags":null,"title":"Photo","uri":"https://sky-bro.github.io/en/gallery/photo/"}]