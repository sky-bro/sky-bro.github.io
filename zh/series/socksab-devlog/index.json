[{"content":"用Vscode和Cmake创建一个简单的qt应用，以后可以当成qt应用的模板使用\n模板代码放在github.com/sky-bro/Qt-Cmake-Example\n工具准备 安装qt5-base，qtcreator，cmake\n安装VSCode插件，CMake和CMake Tools\nCMakeLists.txt说明 顶层CMakeLists.txt 首先文件目录结构如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  . ├── CMakeLists.txt ├── lib │ ├── add.cpp │ ├── add.h │ └── CMakeLists.txt ├── Socks-Alice │ ├── CMakeLists.txt │ ├── dialog.cpp │ ├── dialog.h │ ├── dialog.ui │ └── main.cpp └── Socks-Bob ├── CMakeLists.txt └── main.cpp   有三个子目录，lib存放底层逻辑实现，编译成库，给Socks-Alice和Socks-Bob链接，Socks-Alice属于代理软件客户端，有gui，Socks-Bob属于代理软件服务端，没有gui。三个子目录也都有自己的CMakeLists.txt文件。\n顶层的CMakeLists.txt如下，这里主要用来控制整个项目的设置，导入/寻找一些库，以及添加三个子目录add_subdirectory\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  cmake_minimum_required(VERSION 3.5)project(Qt-CMake-Example VERSION 1.0 LANGUAGES CXX)set(CMAKE_CXX_STANDARD 14)set(CMAKE_CXX_STANDARD_REQUIRED True)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTORCC ON)find_package(QT NAMES Qt6 Qt5 COMPONENTS Network Widgets LinguistTools REQUIRED)find_package(Qt${QT_VERSION_MAJOR} COMPONENTS Network Widgets LinguistTools REQUIRED)find_package(PkgConfig)pkg_search_module(BOTAN REQUIRED botan-2\u0026gt;=2.3.0)find_library(BOTAN_LIBRARY_VAR # /usr/include/botan-2  NAMES ${BOTAN_LIBRARIES} # botan-2  HINTS ${BOTAN_LIBRARY_DIRS} ${BOTAN_LIBDIR}) # \u0026#34;\u0026#34; /usr/lib add_subdirectory(lib)add_subdirectory(Socks-Alice)add_subdirectory(Socks-Bob)  lib中的CMakeLists.txt 这里为了示例，只在lib中添加了一个加法函数，放在add.h和add.cpp中\n1 2 3 4 5 6 7 8 9 10 11 12 13  // add.h /** * @brief add two numbers together * @param a first number * @param b second number * @returns a+b */ int add(int a, int b); // add.cpp int add(int a, int b) { return a + b; }   lib下的CMakeLists.txt如下，这里还给它链接了qt的network库以及第三方的botan-2（一个C++密码库，在顶层的CMakeLists.txt中导入的），通过add_library将其编译成一个库socksAB（STATIC默认）\n1 2 3 4 5 6 7 8 9 10 11  set(SOURCE add.cpp)add_library(socksAB ${SOURCE})target_link_libraries(socksAB PUBLIC Qt${QT_VERSION_MAJOR}::Network PRIVATE ${BOTAN_LIBRARY_VAR})target_include_directories(socksAB PRIVATE ${BOTAN_INCLUDE_DIRS})  Socks-Alice中的CMakeLists.txt Socks-Alice中的gui编辑部分可以用qtcreator来做，通常它会自动为我们添加三个文件：xxx.cpp，xxx.h和xxx.ui，但可能需要我们自己手动将它们添加到SOURCE中，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  set(SOURCE dialog.cpp dialog.h dialog.ui main.cpp )add_executable(Socks-Alice ${SOURCE})target_link_libraries(Socks-Alice PRIVATE socksAB)target_link_libraries(Socks-Alice PRIVATE Qt${QT_VERSION_MAJOR}::Widgets)target_include_directories(Socks-Alice PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; \u0026#34;${PROJECT_SOURCE_DIR}/lib\u0026#34; PRIVATE ${BOTAN_INCLUDE_DIRS} )  对应的main.cpp（就是简单显示一下这个窗口）\n1 2 3 4 5 6 7 8 9 10  #include \u0026#34;dialog.h\u0026#34;#include \u0026lt;QApplication\u0026gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); Dialog w; w.show(); return a.exec(); }   Socks-Bob中的CMakeLists.txt 和Socks-Alice类似，但没有链接qt的widget库（因为Socks-Bob放在服务器上，我们不需要GUI）\n1 2 3 4 5 6 7 8 9 10 11  add_executable(Socks-Bob main.cpp )target_link_libraries(Socks-Bob socksAB)target_include_directories(Socks-Bob PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; \u0026#34;${PROJECT_SOURCE_DIR}/lib\u0026#34; PRIVATE ${BOTAN_INCLUDE_DIRS} )  这里的main.cpp使用了lib中的add函数，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;iostream\u0026gt; #include \u0026#34;add.h\u0026#34; using namespace std; int main(int argc, char const *argv[]) { int a, b; cout \u0026lt;\u0026lt; \u0026#34;hello from Socks-Bob\\n\u0026#34;; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; add(a, b) \u0026lt;\u0026lt; endl; return 0; }   编译与运行 这里可以借助vscode的插件CMake Tools或者直接命令行中：\n1 2 3 4  mkdir build cd build cmake .. make   将得到build目录结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  ./build ├── CMakeCache.txt ├── CMakeFiles ├── cmake_install.cmake ├── lib │ ├── CMakeFiles │ ├── cmake_install.cmake │ ├── libsocksAB.a │ ├── Makefile │ └── socksAB_autogen ├── Makefile ├── Socks-Alice │ ├── CMakeFiles │ ├── cmake_install.cmake │ ├── Makefile │ ├── Socks-Alice │ └── Socks-Alice_autogen └── Socks-Bob ├── CMakeFiles ├── cmake_install.cmake ├── Makefile ├── Socks-Bob └── Socks-Bob_autogen   可以运行相应目录运行./Socks-Alice或者./Socks-Bob\n参考  cutter.re: Development env setup ","description":"","id":0,"section":"posts","tags":[""],"title":"(1) Qt, VSCode and CMake","uri":"https://k4i.top/zh/posts/socksab-devlog/1-qt-vscode-and-cmake/"},{"content":"准备用qt写一个简单的fq/代理软件，叫做SocksAB，分为服务端Socks-Bob和客户端Socks-Alice两个部分。\n程序源代码托管在github.com/sky-bro/SocksAB\n原理介绍 首先正常情况下，我们要访问远端的某个服务，这中间我们的通信是可能会被GFW掐断的\n而fq/代理软件的原理则其实非常简单，我们不直接访问服务器，而是将需要的数据/请求通过我们的一个服务器中转一下。而这个服务器通常是我们能够从国内直接访问，所以我们的fq实际就是利用了GFW并没有把所有的能访问google.com的电脑(ip)都封杀掉，我们只要能访问到这些电脑(ip)，就能访问到google.com。\n具体来说，正常的fq/代理软件都一定至少会有两个部分，一个客户端，用来收集本地的代理请求；还有一个服务端，接收这些请求，并去向真正的服务器完成这些请求。\n 只有一个部分原理上也是可以的，就是比如直接在你的国外某服务器上搞一个Socks5代理或是http代理，然后你的电脑上直接为你的软件设好相应的代理。\n问题就是我们使用的软件所支持的代理方式（主要就是socks和http）都是很容易被GFW发现的，这样直接的代理方式是用不了多久了\n 首先Socks-Alice需要实现Socks5代理或是http代理，这样我们的浏览器或是其它啥软件就可以配置走这个代理了。接着代理软件客户端Socks-Alice通过一系列操作将请求发给代理软件服务端Socks-Bob，这中间具体路径是怎么走的（比如有没有再经过更多人中转），或是数据内容怎么样形式发送的（加密或是伪装）都是很自由的，只要Socks-Bob能够理解，解析拿到正确的请求，发给真正的服务器即可。如下图：\n所以一个fq/代理软件的核心是要实现Socks-Alice与Socks-Bob间的数据传递。目前比较好的方式就是使用AEAD ciphers加密传输，以及伪装成tls流量。\n加密 等着后面慢慢\n伪装 再补充\n参考链接  socks5 rfc1928 ","description":"","id":1,"section":"posts","tags":[""],"title":"(0) SocksAB Intro","uri":"https://k4i.top/zh/posts/socksab-devlog/0-socksab-intro/"},{"content":"本教程展示如何搭建clusterfuzz进行本地测试，教程使用的clusterfuzz版本为v2.0.1 (推荐总是使用最新的release版本)。\n我的clusterfuzz将搭建在ubuntu18.04 docker容器中。最后提供一个dockerfile作为参考，下面内容基本是将dockerfile中的步骤一步步展开\n其实我的步骤基本也是按照官方教程来的，但主要由于国内网络原因，一些地方需要科学上网。\n我使用的是clash分流，也是运行在docker容器内，为了简单我的clash容器和ubuntu容器都是设置的network为host（原因是我发现在ubuntu中尽管设置了no_proxy，有的时候还是会代理127.0.0.1，具体原因不清楚，反正为了简单粗暴就先network用host，代理了也不怕，clash中会设置为直连）\n运行ubuntu18.04 我提供了一个修改软件源后的ubuntu镜像：ubuntu-cn，比较方便\n所以运行容器docker:\n1 2 3 4 5 6  # 你在克隆仓库的时候也可以按下一步设置下代理，快一些 (几十M) git clone https://github.com/google/clusterfuzz.git cd clusterfuzz # 使用需要的版本，推荐用最新版本，当前是v2.0.1 git checkout -b testv2.0.1 v2.0.1 # 我使用-b创建了一个新分支，随意，也可以不用 docker container run --network host --name clusterfuzz -it -v $(pwd):/clusterfuzz skybro/ubuntu-cn:18.04 # 我只测试了ubuntu18.04   设置好代理 后续的操作没特别说明的话就都是在容器内了\n1 2 3 4 5 6  # 感觉设置http代理比socks代理要适用性更广一些，我用的clash，默认http代理端口为7890 # 这里因为我上面network给设的host才用127.0.0.1地址 # 具体替换为你自己的代理地址就好 export http_proxy=http://127.0.0.1:7890 export https_proxy=http://127.0.0.1:7890 export no_proxy=127.0.0.0/8 # 这个对于我这host network，设不设都行了，因为我clash中设置了直连（我发现即使设置了no_proxy，有的时候还是会走代理，所以直接network采用的host）   安装一些软件 基础软件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  apt-get update \u0026amp;\u0026amp; \\  apt-get upgrade -y \u0026amp;\u0026amp; \\  apt-get autoremove -y \u0026amp;\u0026amp; \\  apt-get install -y \\  apt-transport-https \\  build-essential \\  curl \\  gdb \\  libbz2-dev \\  libcurl4-openssl-dev \\  libffi-dev \\  libgdbm-dev \\  liblzma-dev \\  libncurses5-dev \\  libnss3-dev \\  libreadline-dev \\  libssl-dev \\  locales \\  lsb-release \\  net-tools \\  socat \\  sudo \\  unzip \\  util-linux \\  wget \\  zip \\  zlib1g-dev \\  patchelf \\  git \\  vim   google-cloud-sdk 1 2 3 4  CLOUD_SDK_REPO=\u0026#34;cloud-sdk-$(lsb_release -c -s)\u0026#34; \u0026amp;\u0026amp; \\  echo \u0026#34;deb https://packages.cloud.google.com/apt $CLOUD_SDK_REPOmain\u0026#34; | tee -a /etc/apt/sources.list.d/google-cloud-sdk.list \u0026amp;\u0026amp; \\  curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add - \u0026amp;\u0026amp; \\  apt-get update \u0026amp;\u0026amp; apt-get install -y google-cloud-sdk   Python3.7 1 2 3  curl -sS https://www.python.org/ftp/python/3.7.7/Python-3.7.7.tgz | tar -C /tmp -xzv (cd /tmp/Python-3.7.7 \u0026amp;\u0026amp; ./configure --enable-optimizations \u0026amp;\u0026amp; make altinstall \u0026amp;\u0026amp; rm -rf /tmp/Python-3.7.7) pip3.7 install --upgrade pip \u0026amp;\u0026amp; pip3.7 install wheel \u0026amp;\u0026amp; pip3.7 install pipenv   golang 1  apt install -y golang   java 1  apt install -y openjdk-8-jdk   gcloud依赖 1 2 3 4 5 6 7  apt-get install -y \\  google-cloud-sdk-app-engine-go \\  google-cloud-sdk-app-engine-python \\  google-cloud-sdk-app-engine-python-extras \\  google-cloud-sdk \\  google-cloud-sdk-datastore-emulator \\  google-cloud-sdk-pubsub-emulator   python依赖 1 2 3  cd clusterfuzz python3.7 -m pipenv --python 3.7 python3.7 -m pipenv sync --dev   其它依赖 1 2 3 4 5 6 7 8 9  pipenv shell # 进入python虚拟环境 nodeenv -p --prebuilt # 可能需要反复多尝试几次，应该很快的，慢的话就CTRL+C再重来 # 因为我是root用户，需要下面这两行 ref: https://stackoverflow.com/questions/51811564/sh-1-node-permission-denied npm config set unsafe-perm true npm install -g bower polymer-bundler # bower install # 同样因为我是root用户，需要加上--allow-root bower install --allow-root python butler.py bootstrap   运行 启动虚拟环境 上面已经启动了，就是进入clusterfuzz目录，然后运行pipenv shell\n1 2  cd /clusterfuzz pipenv shell   butler.py butler就是管家的意思，我们通过这个python文件执行各种功能，查看帮助python butler.py --help\n平时主要用到就两个功能\n启动网页(App Engine) 查看帮助: python butler.py run_server --help\n第一次运行需要加上-b选项(--bootstrap)，以后就不用了，另外推荐加上--skip-install-deps (不加上每次都安装很多东西，感觉是我们之前依赖都已经装过了，我试过加上没事，有问题再去掉这个选项): python butler.py run_server -b --skip-install-deps，看到下面内容就运行ok了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  (clusterfuzz) root@manjaro:/clusterfuzz# python butler.py run_server -b --skip-install-deps Running: pkill -KILL -f \u0026#34;dev_appserver.py\u0026#34; | Return code is non-zero (-9). Running: pkill -KILL -f \u0026#34;CloudDatastore.jar\u0026#34; | Return code is non-zero (-9). Running: pkill -KILL -f \u0026#34;pubsub-emulator\u0026#34; | Return code is non-zero (-9). Running: pkill -KILL -f \u0026#34;run_bot\u0026#34; | Return code is non-zero (-9). Created symlink: source: /clusterfuzz/configs/test, target /clusterfuzz/src/appengine/config. Created symlink: source: /clusterfuzz/src/protos, target /clusterfuzz/src/appengine/protos. Created symlink: source: /clusterfuzz/src/python, target /clusterfuzz/src/appengine/python. Running: python polymer_bundler.py (cwd=\u0026#39;local\u0026#39;) | Building templates for App Engine... | App Engine templates built successfully. Created symlink: source: /clusterfuzz/local/storage/local_gcs, target /clusterfuzz/src/appengine/local_gcs. Running: gunicorn -b :9000 main:app (cwd=\u0026#39;src/appengine\u0026#39;) | [2020-05-19 09:24:25 +0800] [22845] [INFO] Starting gunicorn 20.0.4 | [2020-05-19 09:24:25 +0800] [22845] [INFO] Listening at: http://0.0.0.0:9000 (22845) | [2020-05-19 09:24:25 +0800] [22845] [INFO] Using worker: sync | [2020-05-19 09:24:25 +0800] [22855] [INFO] Booting worker with pid: 22855 Bootstrapping datastore... Running: python butler.py run setup --non-dry-run --local --config-dir=configs/test | Creating config | Creating fuzzer afl | Creating fuzzer libFuzzer | Creating fuzzer honggfuzz | Creating fuzzer syzkaller | Creating template afl | Creating template engine_asan | Creating template engine_msan | Creating template engine_ubsan | Creating template honggfuzz | Creating template libfuzzer | Creating template syzkaller | Creating template prune | Done   之后的运行都不需要加-b选项，直接python butler.py run_server --skip-install-deps\n运行fuzzing bots 上面的网页(app engine)相当于只是一个交互界面/控制台而已，具体的fuzzing工作都还需要运行fuzzing bots才行，fuzzing bots可以运行多个，而且可以单独运行在其它容器中（后面再试，现在直接还在这个容器中运行）\n另外，我在docker容器内运行的ubuntu，要多开一个命令行的话可以使用tmux\n安装tmux: apt install tmux\n或者主机上在运行的容器上再开一个shell\n1 2 3 4 5 6  docker container exec -it clusterfuzz bash root@manjaro:/# cd /clusterfuzz root@manjaro:/clusterfuzz# pipenv shell Launching subshell in virtual environment… root@manjaro:/clusterfuzz# . /root/.local/share/virtualenvs/clusterfuzz-rAL0Uxhl/bin/activate (clusterfuzz) root@manjaro:/clusterfuzz#   查看运行bots的帮助: python butler.py run_bot --help\n运行效果如下\n1  python butler.py run_bot --name bot01 ./bot01 # rename my-bot to anything   测试 这里的步骤可以参考官方教程，比较详细: Setting up fuzzing\n我这里简单地进行部分翻译，下面的操作不用在容器内进行\n安装libfuzzer debian系统可参考LLVM Debian/Ubuntu nightly packages，我也不清楚到底安装哪些，也没找到好的教程，源码安装感觉不太方便，直接用包管理器应该就行，熟悉这块儿的欢迎留言告诉。\n编写fuzzer 我这里直接使用这里的fuzz_me.cc:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;stdint.h\u0026gt;#include \u0026lt;stddef.h\u0026gt; bool FuzzMe(const uint8_t *Data, size_t DataSize) { return DataSize \u0026gt;= 3 \u0026amp;\u0026amp; Data[0] == \u0026#39;F\u0026#39; \u0026amp;\u0026amp; Data[1] == \u0026#39;U\u0026#39; \u0026amp;\u0026amp; Data[2] == \u0026#39;Z\u0026#39; \u0026amp;\u0026amp; Data[3] == \u0026#39;Z\u0026#39;; // :‑\u0026lt; } extern \u0026#34;C\u0026#34; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) { FuzzMe(Data, Size); return 0; }   上传fuzzer进行测试 编译，压缩\n1 2  clang++ -g fuzz_me.cc -o fuzz_me -fsanitize=address,undefined,fuzzer zip fuzz_me.zip fuzz_me   在jobs页面最底下填写ADD NEW JOB表格(具体怎么填看官方文档: Creating a job type)，然后点击ADD添加\n在Fuzzers页面选择libFuzzer，点击EDIT，勾选刚才的job，提交SUBMIT\n查看结果 常见问题  如果你是直接在本机ubuntu上测试，有些命令需要用sudo才能执行，而环境变量http_proxy和https_proxy很可能不会被继承，及用sudo执行命令很可能不会走代理，你可以参考How to run “sudo apt-get update” through proxy in commandline?进行设置:\n即执行visudo，在Defaults env_reset所在行下面添加\nDefaults env_keep=\u0026quot;http_proxy https_proxy ftp_proxy DISPLAY XAUTHORITY\u0026quot; 啊的  参考  安装及使用主要参考clusterfuzz官方文档 安装过程还主要参考了clusterfuzz仓库内的两个文件: Dockerfile, install_deps_linux.bash libFuzzer的使用参考libFuzzer Tutorial和libfuzzer官方文档  ","description":"","id":2,"section":"posts","tags":[""],"title":"Clusterfuzz Local Setup","uri":"https://k4i.top/zh/posts/clusterfuzz-local-setup/"}]