[{"content":"什么是窗口管理器 窗口管理器 (Window Manager) 就是用来管理窗口的. 主要分为两大类:\nStacking WM: 每个窗口都可以拖拽, 改变大小, 窗口之间可以有重叠, 主要靠鼠标控制.\n比如下图, Stacking WM的屏幕利用率比较低, 而且操作严重依赖鼠标, 比较慢.\nTiling WM: 窗口不能拖拽, 窗口之间没有重叠, 像瓷砖一样铺满屏幕, 配合很多快捷键使用, 基本不或\n者少依赖鼠标进行控制.\n自动放置窗口, 不重叠, 空间利用率高 多种布局方式切换, 适应各种需求 (基本所有tiling wm都不止Tiling一种布局, 比如i3wm还有Tabbed, Stacked, 还可以选择让某窗口全屏或是悬浮) 基本全靠键盘控制, 快速方便 container与tree 我这里并没有严格去看源码这个树到底是怎么构建的(尤其是很多特殊情况), 不过就简单理解下树和窗口之间的关系是可以的. 大多窗口管理器采用树结构来保存窗口, i3也是如此.\n每个workspace的所有窗口保存在一个tree数据结构里面, 这个tree的每个节点都是一个 container (window算特殊的container, 是没有孩子的叶子节点), 一个container里面又可以包含多个container.\ncontainer属性 每个container有两个比较重要的属性:\n布局方式 split (分splith, splitv), tabbed 或者 stacked\nFigure 1: tree of ambiguous layout\n图 1 代表的窗口可能是图 2, 也可能是图 3或者其他的, 因为我们不知道每个container内部的窗口布局方式. 所以窗口管理器会为每个节点保存布局方式, 表示内部的孩子节点应该按照什么方式放置.\nFigure 2: possible window status 01\nFigure 3: possible window status 02\n所以如果想只代表图 2 中的窗口, 那么应该为container增加布局方式属性, 如图 1 所示.\nFigure 4: tree of unambiguous layout\nsplit方向对应占多少百分比 因为我们通常还会控制每个窗口/容器的宽度/高度, 所以还应该为每个容器增加split方向的空间占比, 如图 5 所示.\nFigure 5: tree with container percentage\n练习与理解 为了理解我们在操作窗口时对应tree的构造, 我们将窗口/容器都放在另一个设为tabbed或\n者stacked布局的容器内 \u0026ndash; 因为这两种布局才会显示标题.\n切换到一个没有任何窗口的workspace: 如 $Mod+3. 用 $Mod+e 设置默认的布局为split(水平/垂直), (一般不会设为tabbed或stacked). $Mod+ENTER 打开一个terminal (我这里是st, 或者任何别的窗口也行). $Mod+w/s 设置所在container布局为tabbed或stacked $Mod+v/V 新建一个垂直/水平split布局的container包裹当前的st窗口 在节点(container或window)所在container只有一个窗口, 且container布局方式为水平/垂直split时, $Mod+v/V 只会切换split方向 当节点所在container不止一个窗口, 或者container布局方式为tabbed或者stacked时, $Mod+v/V 会创建一个新的垂直/水平split布局的container包裹当前节点 后续在这个stabbed或者stacked container下操作就可以看到标题了 当前看到标题应该为 V[st], 再 $Mod+ENTER 之后显示为 V[st st].\nTips:\n使用 $Mod+c 或者 $Mod+p 来选择孩子或父亲节点窗口, 然后对该节点进行操作:\n创建一个兄弟节点 删除/关闭节点窗口 (节点下所有窗口都会被关闭) 移动节点窗口 修改节点窗口大小 快捷键设置 这里仅列出了比较重要的快捷键, 我详细的配置放在了github的.dotfiles仓库.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # some configs from my ~/.config/i3/config set $mod Mod4 set $up k set $down j set $left h set $right l # change focus bindsym $mod+$left focus left bindsym $mod+$down focus down bindsym $mod+$up focus up bindsym $mod+$right focus right # move focused window bindsym $mod+Shift+$left move left bindsym $mod+Shift+$down move down bindsym $mod+Shift+$up move up bindsym $mod+Shift+$right move right # split in horizontal orientation bindsym $mod+Shift+v split h # split in vertical orientation bindsym $mod+v split v # enter fullscreen mode for the focused container bindsym $mod+f fullscreen toggle # change container layout (stacked, tabbed, toggle split) bindsym $mod+s layout stacking bindsym $mod+w layout tabbed bindsym $mod+e layout toggle split # toggle tiling / floating bindsym $mod+Shift+space floating toggle # change focus between tiling / floating windows bindsym $mod+space focus mode_toggle # focus the parent container bindsym $mod+p focus parent # focus the child container bindsym $mod+c focus child # resize window (you can also use the mouse for that) set $resize_step 5 bindsym $mod+y resize shrink width $resize_step px or $resize_step ppt bindsym $mod+i resize grow height $resize_step px or $resize_step ppt bindsym $mod+u resize shrink height $resize_step px or $resize_step ppt bindsym $mod+o resize grow width $resize_step px or $resize_step ppt Mod-h/j/k/l 切换到左/上/下/右边窗口 Mod-S-h/j/k/l 移动窗口/容器 Mod-y/u/i/o 调整窗口/容器大小 Mod-v 增加一个container 存放当前focused window(或者container), 容器内采用垂直split布局 Mod-S-v 同上, 不过容器内采用水平split布局 Mod-e/w/s 设置 所在container 的布局为Split(会在splith, splitv间循环), Tabbed, Stacked Mod-p Focus parent Mod-c Focus child 参考 i3wm 用户手册 \u0026gt;\u0026gt; tree youtube: TheAlternative.ch - LinuxDays FS16 - Linux for Experts course wiki: window manager types ","description":"notes on i3 tiling wm.","id":0,"section":"posts","tags":["wm"],"title":"Tiling WM (i3)","uri":"https://k4i.top/zh/posts/tiling-wm--i3/"},{"content":" 🚩 关于本站 使用Hugo生成，博客源码在blog-src, 主题fork(my fork)自: hugo-theme-zzo.\n另外现在不直接编辑 .md 文件了, 而是先编辑 .org 文件 (保存到了\nblog-src/content-org), 然后用ox-hugo导出到 .md.\n🌅 我的日常 @哈工大 C/C++, Golang, Python, ASM Arch, Eamcs, VSCode CTF, ACM 💌 联系我 邮件: sky_io@outlook.com 微信: sky_bro 脸书: Kaiyu Shi 推特: KaiyuShi GPG公钥: Kyle.asc (F4CD 0E4A 3661 65D1 62E6 B6CE 7D36 AE60 55B0 60A6) 🐔 我的朋友 TheSong, 路人枭, wxk\n🎼 最近在听 ","description":"about k4i","id":1,"section":"","tags":null,"title":"关于","uri":"https://k4i.top/zh/about/"},{"content":"用Vscode和Cmake创建一个简单的qt应用，以后可以当成qt应用的模板使用\n模板代码放在github.com/sky-bro/Qt-Cmake-Example\n工具准备 安装qt5-base，qtcreator，cmake\n安装VSCode插件，CMake和CMake Tools\nCMakeLists.txt说明 顶层CMakeLists.txt 首先文件目录结构如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . ├── CMakeLists.txt ├── lib │ ├── add.cpp │ ├── add.h │ └── CMakeLists.txt ├── Socks-Alice │ ├── CMakeLists.txt │ ├── dialog.cpp │ ├── dialog.h │ ├── dialog.ui │ └── main.cpp └── Socks-Bob ├── CMakeLists.txt └── main.cpp 有三个子目录，lib存放底层逻辑实现，编译成库，给Socks-Alice和Socks-Bob链接，Socks-Alice属于代理软件客户端，有gui，Socks-Bob属于代理软件服务端，没有gui。三个子目录也都有自己的CMakeLists.txt文件。\n顶层的CMakeLists.txt如下，这里主要用来控制整个项目的设置，导入/寻找一些库，以及添加三个子目录add_subdirectory\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 cmake_minimum_required(VERSION 3.5) project(Qt-CMake-Example VERSION 1.0 LANGUAGES CXX) set(CMAKE_CXX_STANDARD 14) set(CMAKE_CXX_STANDARD_REQUIRED True) set(CMAKE_AUTOUIC ON) set(CMAKE_AUTOMOC ON) set(CMAKE_AUTORCC ON) find_package(QT NAMES Qt6 Qt5 COMPONENTS Network Widgets LinguistTools REQUIRED) find_package(Qt${QT_VERSION_MAJOR} COMPONENTS Network Widgets LinguistTools REQUIRED) find_package(PkgConfig) pkg_search_module(BOTAN REQUIRED botan-2\u0026gt;=2.3.0) find_library(BOTAN_LIBRARY_VAR # /usr/include/botan-2 NAMES ${BOTAN_LIBRARIES} # botan-2 HINTS ${BOTAN_LIBRARY_DIRS} ${BOTAN_LIBDIR}) # \u0026#34;\u0026#34; /usr/lib add_subdirectory(lib) add_subdirectory(Socks-Alice) add_subdirectory(Socks-Bob) lib中的CMakeLists.txt 这里为了示例，只在lib中添加了一个加法函数，放在add.h和add.cpp中\n1 2 3 4 5 6 7 8 9 10 11 12 13 // add.h /** * @brief add two numbers together * @param a first number * @param b second number * @returns a+b */ int add(int a, int b); // add.cpp int add(int a, int b) { return a + b; } lib下的CMakeLists.txt如下，这里还给它链接了qt的network库以及第三方的botan-2（一个C++密码库，在顶层的CMakeLists.txt中导入的），通过add_library将其编译成一个库socksAB（STATIC默认）\n1 2 3 4 5 6 7 8 9 10 11 set(SOURCE add.cpp) add_library(socksAB ${SOURCE}) target_link_libraries(socksAB PUBLIC Qt${QT_VERSION_MAJOR}::Network PRIVATE ${BOTAN_LIBRARY_VAR}) target_include_directories(socksAB PRIVATE ${BOTAN_INCLUDE_DIRS}) Socks-Alice中的CMakeLists.txt Socks-Alice中的gui编辑部分可以用qtcreator来做，通常它会自动为我们添加三个文件：xxx.cpp，xxx.h和xxx.ui，但可能需要我们自己手动将它们添加到SOURCE中，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 set(SOURCE dialog.cpp dialog.h dialog.ui main.cpp ) add_executable(Socks-Alice ${SOURCE}) target_link_libraries(Socks-Alice PRIVATE socksAB) target_link_libraries(Socks-Alice PRIVATE Qt${QT_VERSION_MAJOR}::Widgets) target_include_directories(Socks-Alice PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; \u0026#34;${PROJECT_SOURCE_DIR}/lib\u0026#34; PRIVATE ${BOTAN_INCLUDE_DIRS} ) 对应的main.cpp（就是简单显示一下这个窗口）\n1 2 3 4 5 6 7 8 9 10 #include \u0026#34;dialog.h\u0026#34; #include \u0026lt;QApplication\u0026gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); Dialog w; w.show(); return a.exec(); } Socks-Bob中的CMakeLists.txt 和Socks-Alice类似，但没有链接qt的widget库（因为Socks-Bob放在服务器上，我们不需要GUI）\n1 2 3 4 5 6 7 8 9 10 11 add_executable(Socks-Bob main.cpp ) target_link_libraries(Socks-Bob socksAB) target_include_directories(Socks-Bob PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; \u0026#34;${PROJECT_SOURCE_DIR}/lib\u0026#34; PRIVATE ${BOTAN_INCLUDE_DIRS} ) 这里的main.cpp使用了lib中的add函数，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026#34;add.h\u0026#34; using namespace std; int main(int argc, char const *argv[]) { int a, b; cout \u0026lt;\u0026lt; \u0026#34;hello from Socks-Bob\\n\u0026#34;; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; add(a, b) \u0026lt;\u0026lt; endl; return 0; } 编译与运行 这里可以借助vscode的插件CMake Tools或者直接命令行中：\n1 2 3 4 mkdir build cd build cmake .. make 将得到build目录结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ./build ├── CMakeCache.txt ├── CMakeFiles ├── cmake_install.cmake ├── lib │ ├── CMakeFiles │ ├── cmake_install.cmake │ ├── libsocksAB.a │ ├── Makefile │ └── socksAB_autogen ├── Makefile ├── Socks-Alice │ ├── CMakeFiles │ ├── cmake_install.cmake │ ├── Makefile │ ├── Socks-Alice │ └── Socks-Alice_autogen └── Socks-Bob ├── CMakeFiles ├── cmake_install.cmake ├── Makefile ├── Socks-Bob └── Socks-Bob_autogen 可以运行相应目录运行./Socks-Alice或者./Socks-Bob\n参考 cutter.re: Development env setup ","description":"","id":2,"section":"posts","tags":[null],"title":"(1) Qt, VSCode and CMake","uri":"https://k4i.top/zh/posts/socksab-devlog/1-qt-vscode-and-cmake/"},{"content":"准备用qt写一个简单的fq/代理软件，叫做SocksAB，分为服务端Socks-Bob和客户端Socks-Alice两个部分。\n程序源代码托管在github.com/sky-bro/SocksAB\n原理介绍 首先正常情况下，我们要访问远端的某个服务，这中间我们的通信是可能会被GFW掐断的\n而fq/代理软件的原理则其实非常简单，我们不直接访问服务器，而是将需要的数据/请求通过我们的一个服务器中转一下。而这个服务器通常是我们能够从国内直接访问，所以我们的fq实际就是利用了GFW并没有把所有的能访问google.com的电脑(ip)都封杀掉，我们只要能访问到这些电脑(ip)，就能访问到google.com。\n具体来说，正常的fq/代理软件都一定至少会有两个部分，一个客户端，用来收集本地的代理请求；还有一个服务端，接收这些请求，并去向真正的服务器完成这些请求。\n只有一个部分原理上也是可以的，就是比如直接在你的国外某服务器上搞一个Socks5代理或是http代理，然后你的电脑上直接为你的软件设好相应的代理。\n问题就是我们使用的软件所支持的代理方式（主要就是socks和http）都是很容易被GFW发现的，这样直接的代理方式是用不了多久了\n首先Socks-Alice需要实现Socks5代理或是http代理，这样我们的浏览器或是其它啥软件就可以配置走这个代理了。接着代理软件客户端Socks-Alice通过一系列操作将请求发给代理软件服务端Socks-Bob，这中间具体路径是怎么走的（比如有没有再经过更多人中转），或是数据内容怎么样形式发送的（加密或是伪装）都是很自由的，只要Socks-Bob能够理解，解析拿到正确的请求，发给真正的服务器即可。如下图：\n所以一个fq/代理软件的核心是要实现Socks-Alice与Socks-Bob间的数据传递。目前比较好的方式就是使用AEAD ciphers加密传输，以及伪装成tls流量。\n加密 等着后面慢慢\n伪装 再补充\n参考链接 socks5 rfc1928 ","description":"","id":3,"section":"posts","tags":[null],"title":"(0) SocksAB Intro","uri":"https://k4i.top/zh/posts/socksab-devlog/0-socksab-intro/"},{"content":"本教程展示如何搭建clusterfuzz进行本地测试，教程使用的clusterfuzz版本为v2.0.1 (推荐总是使用最新的release版本)。\n我的clusterfuzz将搭建在ubuntu18.04 docker容器中。最后提供一个dockerfile作为参考，下面内容基本是将dockerfile中的步骤一步步展开\n其实我的步骤基本也是按照官方教程来的，但主要由于国内网络原因，一些地方需要科学上网。\n我使用的是clash分流，也是运行在docker容器内，为了简单我的clash容器和ubuntu容器都是设置的network为host（原因是我发现在ubuntu中尽管设置了no_proxy，有的时候还是会代理127.0.0.1，具体原因不清楚，反正为了简单粗暴就先network用host，代理了也不怕，clash中会设置为直连）\n运行ubuntu18.04 我提供了一个修改软件源后的ubuntu镜像：ubuntu-cn，比较方便\n所以运行容器docker:\n1 2 3 4 5 6 # 你在克隆仓库的时候也可以按下一步设置下代理，快一些 (几十M) git clone https://github.com/google/clusterfuzz.git cd clusterfuzz # 使用需要的版本，推荐用最新版本，当前是v2.0.1 git checkout -b testv2.0.1 v2.0.1 # 我使用-b创建了一个新分支，随意，也可以不用 docker container run --network host --name clusterfuzz -it -v $(pwd):/clusterfuzz skybro/ubuntu-cn:18.04 # 我只测试了ubuntu18.04 设置好代理 后续的操作没特别说明的话就都是在容器内了\n1 2 3 4 5 6 # 感觉设置http代理比socks代理要适用性更广一些，我用的clash，默认http代理端口为7890 # 这里因为我上面network给设的host才用127.0.0.1地址 # 具体替换为你自己的代理地址就好 export http_proxy=http://127.0.0.1:7890 export https_proxy=http://127.0.0.1:7890 export no_proxy=127.0.0.0/8 # 这个对于我这host network，设不设都行了，因为我clash中设置了直连（我发现即使设置了no_proxy，有的时候还是会走代理，所以直接network采用的host） 安装一些软件 基础软件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 apt-get update \u0026amp;\u0026amp; \\ apt-get upgrade -y \u0026amp;\u0026amp; \\ apt-get autoremove -y \u0026amp;\u0026amp; \\ apt-get install -y \\ apt-transport-https \\ build-essential \\ curl \\ gdb \\ libbz2-dev \\ libcurl4-openssl-dev \\ libffi-dev \\ libgdbm-dev \\ liblzma-dev \\ libncurses5-dev \\ libnss3-dev \\ libreadline-dev \\ libssl-dev \\ locales \\ lsb-release \\ net-tools \\ socat \\ sudo \\ unzip \\ util-linux \\ wget \\ zip \\ zlib1g-dev \\ patchelf \\ git \\ vim google-cloud-sdk 1 2 3 4 CLOUD_SDK_REPO=\u0026#34;cloud-sdk-$(lsb_release -c -s)\u0026#34; \u0026amp;\u0026amp; \\ echo \u0026#34;deb https://packages.cloud.google.com/apt $CLOUD_SDK_REPO main\u0026#34; | tee -a /etc/apt/sources.list.d/google-cloud-sdk.list \u0026amp;\u0026amp; \\ curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add - \u0026amp;\u0026amp; \\ apt-get update \u0026amp;\u0026amp; apt-get install -y google-cloud-sdk Python3.7 1 2 3 curl -sS https://www.python.org/ftp/python/3.7.7/Python-3.7.7.tgz | tar -C /tmp -xzv (cd /tmp/Python-3.7.7 \u0026amp;\u0026amp; ./configure --enable-optimizations \u0026amp;\u0026amp; make altinstall \u0026amp;\u0026amp; rm -rf /tmp/Python-3.7.7) pip3.7 install --upgrade pip \u0026amp;\u0026amp; pip3.7 install wheel \u0026amp;\u0026amp; pip3.7 install pipenv golang 1 apt install -y golang java 1 apt install -y openjdk-8-jdk gcloud依赖 1 2 3 4 5 6 7 apt-get install -y \\ google-cloud-sdk-app-engine-go \\ google-cloud-sdk-app-engine-python \\ google-cloud-sdk-app-engine-python-extras \\ google-cloud-sdk \\ google-cloud-sdk-datastore-emulator \\ google-cloud-sdk-pubsub-emulator python依赖 1 2 3 cd clusterfuzz python3.7 -m pipenv --python 3.7 python3.7 -m pipenv sync --dev 其它依赖 1 2 3 4 5 6 7 8 9 pipenv shell # 进入python虚拟环境 nodeenv -p --prebuilt # 可能需要反复多尝试几次，应该很快的，慢的话就CTRL+C再重来 # 因为我是root用户，需要下面这两行 ref: https://stackoverflow.com/questions/51811564/sh-1-node-permission-denied npm config set unsafe-perm true npm install -g bower polymer-bundler # bower install # 同样因为我是root用户，需要加上--allow-root bower install --allow-root python butler.py bootstrap 运行 启动虚拟环境 上面已经启动了，就是进入clusterfuzz目录，然后运行pipenv shell\n1 2 cd /clusterfuzz pipenv shell butler.py butler就是管家的意思，我们通过这个python文件执行各种功能，查看帮助python butler.py --help\n平时主要用到就两个功能\n启动网页(App Engine) 查看帮助: python butler.py run_server --help\n第一次运行需要加上-b选项(--bootstrap)，以后就不用了，另外推荐加上--skip-install-deps (不加上每次都安装很多东西，感觉是我们之前依赖都已经装过了，我试过加上没事，有问题再去掉这个选项): python butler.py run_server -b --skip-install-deps，看到下面内容就运行ok了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 (clusterfuzz) root@manjaro:/clusterfuzz# python butler.py run_server -b --skip-install-deps Running: pkill -KILL -f \u0026#34;dev_appserver.py\u0026#34; | Return code is non-zero (-9). Running: pkill -KILL -f \u0026#34;CloudDatastore.jar\u0026#34; | Return code is non-zero (-9). Running: pkill -KILL -f \u0026#34;pubsub-emulator\u0026#34; | Return code is non-zero (-9). Running: pkill -KILL -f \u0026#34;run_bot\u0026#34; | Return code is non-zero (-9). Created symlink: source: /clusterfuzz/configs/test, target /clusterfuzz/src/appengine/config. Created symlink: source: /clusterfuzz/src/protos, target /clusterfuzz/src/appengine/protos. Created symlink: source: /clusterfuzz/src/python, target /clusterfuzz/src/appengine/python. Running: python polymer_bundler.py (cwd=\u0026#39;local\u0026#39;) | Building templates for App Engine... | App Engine templates built successfully. Created symlink: source: /clusterfuzz/local/storage/local_gcs, target /clusterfuzz/src/appengine/local_gcs. Running: gunicorn -b :9000 main:app (cwd=\u0026#39;src/appengine\u0026#39;) | [2020-05-19 09:24:25 +0800] [22845] [INFO] Starting gunicorn 20.0.4 | [2020-05-19 09:24:25 +0800] [22845] [INFO] Listening at: http://0.0.0.0:9000 (22845) | [2020-05-19 09:24:25 +0800] [22845] [INFO] Using worker: sync | [2020-05-19 09:24:25 +0800] [22855] [INFO] Booting worker with pid: 22855 Bootstrapping datastore... Running: python butler.py run setup --non-dry-run --local --config-dir=configs/test | Creating config | Creating fuzzer afl | Creating fuzzer libFuzzer | Creating fuzzer honggfuzz | Creating fuzzer syzkaller | Creating template afl | Creating template engine_asan | Creating template engine_msan | Creating template engine_ubsan | Creating template honggfuzz | Creating template libfuzzer | Creating template syzkaller | Creating template prune | Done 之后的运行都不需要加-b选项，直接python butler.py run_server --skip-install-deps\n运行fuzzing bots 上面的网页(app engine)相当于只是一个交互界面/控制台而已，具体的fuzzing工作都还需要运行fuzzing bots才行，fuzzing bots可以运行多个，而且可以单独运行在其它容器中（后面再试，现在直接还在这个容器中运行）\n另外，我在docker容器内运行的ubuntu，要多开一个命令行的话可以使用tmux\n安装tmux: apt install tmux\n或者主机上在运行的容器上再开一个shell\n1 2 3 4 5 6 docker container exec -it clusterfuzz bash root@manjaro:/# cd /clusterfuzz root@manjaro:/clusterfuzz# pipenv shell Launching subshell in virtual environment… root@manjaro:/clusterfuzz# . /root/.local/share/virtualenvs/clusterfuzz-rAL0Uxhl/bin/activate (clusterfuzz) root@manjaro:/clusterfuzz# 查看运行bots的帮助: python butler.py run_bot --help\n运行效果如下\n1 python butler.py run_bot --name bot01 ./bot01 # rename my-bot to anything 测试 这里的步骤可以参考官方教程，比较详细: Setting up fuzzing\n我这里简单地进行部分翻译，下面的操作不用在容器内进行\n安装libfuzzer debian系统可参考LLVM Debian/Ubuntu nightly packages，我也不清楚到底安装哪些，也没找到好的教程，源码安装感觉不太方便，直接用包管理器应该就行，熟悉这块儿的欢迎留言告诉。\n编写fuzzer 我这里直接使用这里的fuzz_me.cc:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; bool FuzzMe(const uint8_t *Data, size_t DataSize) { return DataSize \u0026gt;= 3 \u0026amp;\u0026amp; Data[0] == \u0026#39;F\u0026#39; \u0026amp;\u0026amp; Data[1] == \u0026#39;U\u0026#39; \u0026amp;\u0026amp; Data[2] == \u0026#39;Z\u0026#39; \u0026amp;\u0026amp; Data[3] == \u0026#39;Z\u0026#39;; // :‑\u0026lt; } extern \u0026#34;C\u0026#34; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) { FuzzMe(Data, Size); return 0; } 上传fuzzer进行测试 编译，压缩\n1 2 clang++ -g fuzz_me.cc -o fuzz_me -fsanitize=address,undefined,fuzzer zip fuzz_me.zip fuzz_me 在jobs页面最底下填写ADD NEW JOB表格(具体怎么填看官方文档: Creating a job type)，然后点击ADD添加\n在Fuzzers页面选择libFuzzer，点击EDIT，勾选刚才的job，提交SUBMIT\n查看结果 常见问题 如果你是直接在本机ubuntu上测试，有些命令需要用sudo才能执行，而环境变量http_proxy和https_proxy很可能不会被继承，及用sudo执行命令很可能不会走代理，你可以参考How to run “sudo apt-get update” through proxy in commandline?进行设置:\n即执行visudo，在Defaults env_reset所在行下面添加\nDefaults env_keep=\u0026quot;http_proxy https_proxy ftp_proxy DISPLAY XAUTHORITY\u0026quot; 啊的 参考 安装及使用主要参考clusterfuzz官方文档 安装过程还主要参考了clusterfuzz仓库内的两个文件: Dockerfile, install_deps_linux.bash libFuzzer的使用参考libFuzzer Tutorial和libfuzzer官方文档 ","description":"","id":4,"section":"posts","tags":[null],"title":"Clusterfuzz Local Setup","uri":"https://k4i.top/zh/posts/clusterfuzz-local-setup/"}]